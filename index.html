<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI-Powered PubMed Research Tool - Professional Edition</title>
  <style>
    /* Professional styling with clear visual hierarchy */
    * {
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      color: #1a5490;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.2em;
    }
    
    h2, h3 { 
      color: #2E5AAC;
      margin-top: 20px;
    }
    
    /* Form elements */
    label { 
      font-weight: 600;
      display: inline-block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #495057;
    }
    
    input, select, button, textarea { 
      margin: 5px 0;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4dabf7;
      box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.1);
    }
    
    button {
      cursor: pointer;
      background-color: #228be6;
      color: white;
      border: none;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    button:hover:not(:disabled) {
      background-color: #1971c2;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    button:disabled { 
      background-color: #e9ecef;
      color: #868e96;
      cursor: not-allowed;
    }
    
    /* Section styling */
    .section { 
      background: white;
      border: 1px solid #dee2e6;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Tab system */
    .tabs {
      display: flex;
      border-bottom: 2px solid #dee2e6;
      margin-bottom: 20px;
      background: white;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }
    
    .tab {
      padding: 12px 24px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-weight: 600;
      color: #495057;
      transition: all 0.3s ease;
      flex: 1;
      text-align: center;
    }
    
    .tab:hover {
      background: #e9ecef;
    }
    
    .tab.active {
      background: white;
      color: #228be6;
      border-bottom: 3px solid #228be6;
      margin-bottom: -2px;
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Status indicators */
    #progress-status { 
      font-style: italic;
      color: #495057;
      margin-top: 10px;
      padding: 10px;
      background: #e7f5ff;
      border-radius: 5px;
      display: inline-block;
    }
    
    /* Output areas */
    .output-area {
      width: 100%;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      background: #f8f9fa;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      line-height: 1.5;
    }
    
    #iteration-log {
      max-height: 500px;
    }
    
    /* MeSH term validation */
    .mesh-valid {
      background-color: #d3f9d8;
      color: #2b8a3e;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    .mesh-invalid {
      background-color: #ffe0e0;
      color: #c92a2a;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    .mesh-unknown {
      background-color: #fff3cd;
      color: #856404;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    /* Search term display */
    .search-term {
      background: #f1f3f5;
      padding: 8px;
      margin: 5px 0;
      border-left: 4px solid #339af0;
      font-family: monospace;
      font-size: 12px;
    }
    
    /* Relevance scores */
    .score-excellent {
      color: #2b8a3e;
      font-weight: bold;
    }
    
    .score-good {
      color: #5c940d;
      font-weight: bold;
    }
    
    .score-medium {
      color: #e67700;
      font-weight: bold;
    }
    
    .score-poor {
      color: #c92a2a;
      font-weight: bold;
    }
    
    /* API test result */
    .api-test-result {
      margin: 10px 0;
      padding: 12px;
      border-radius: 5px;
      font-weight: 500;
    }
    
    .api-test-success {
      background-color: #d3f9d8;
      color: #2b8a3e;
      border: 1px solid #8ce99a;
    }
    
    .api-test-failure {
      background-color: #ffe0e0;
      color: #c92a2a;
      border: 1px solid #ffa8a8;
    }
    
    /* CORS warning */
    #cors-warning {
      background-color: #fff3cd;
      border: 1px solid #ffec99;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    
    #cors-warning code {
      background-color: #f8f9fa;
      padding: 3px 6px;
      border-radius: 3px;
      font-family: monospace;
      border: 1px solid #dee2e6;
    }
    
    /* Token display */
    .token-display {
      background: #e7f5ff;
      padding: 8px 15px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      display: inline-block;
      border: 1px solid #74c0fc;
      margin-left: 20px;
    }
    
    /* Results styling */
    .article-result {
      background: #f8f9fa;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .article-result h4 {
      margin: 0 0 10px 0;
      color: #1a5490;
    }
    
    .article-metadata {
      font-size: 13px;
      color: #6c757d;
      margin: 5px 0;
    }
    
    .article-abstract {
      margin-top: 10px;
      font-style: italic;
      color: #495057;
      line-height: 1.6;
    }
    
    /* Prompt editor */
    .prompt-editor {
      width: 100%;
      height: 200px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      padding: 10px;
      background: #f8f9fa;
    }
    
    .prompt-section {
      margin-bottom: 20px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 15px;
      background: #fafbfc;
    }
    
    .prompt-title {
      font-weight: 600;
      color: #1a5490;
      margin-bottom: 10px;
    }
    
    /* Info boxes */
    .info-box {
      background: #e7f5ff;
      border: 1px solid #74c0fc;
      border-radius: 5px;
      padding: 12px;
      margin: 10px 0;
    }
    
    .warning-box {
      background: #fff3cd;
      border: 1px solid #ffec99;
      border-radius: 5px;
      padding: 12px;
      margin: 10px 0;
      color: #856404;
    }
    
    /* PubMed syntax help */
    .syntax-help {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 15px;
      margin: 15px 0;
    }
    
    .syntax-help h4 {
      margin-top: 0;
      color: #495057;
    }
    
    .syntax-example {
      font-family: monospace;
      background: white;
      padding: 5px 8px;
      border-radius: 3px;
      margin: 2px 0;
      display: inline-block;
    }
    
    /* Buttons */
    .primary-button {
      background-color: #228be6;
      font-size: 16px;
      padding: 12px 24px;
      margin: 10px 0;
    }
    
    .secondary-button {
      background-color: #495057;
      font-size: 14px;
      padding: 8px 16px;
    }
    
    .success-button {
      background-color: #2b8a3e;
    }
    
    .warning-button {
      background-color: #e67700;
    }
    
    .danger-button {
      background-color: #c92a2a;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üî¨ AI-Powered PubMed Research Tool - Professional Edition</h1>
    
    <!-- Tab Navigation -->
    <div class="tabs">
      <button class="tab active" onclick="showTab('search')">üîç Search</button>
      <button class="tab" onclick="showTab('results')">üìä Results</button>
      <button class="tab" onclick="showTab('evolution')">üß¨ Evolution</button>
      <button class="tab" onclick="showTab('prompts')">üìù Prompts</button>
      <button class="tab" onclick="showTab('config')">‚öôÔ∏è Settings</button>
    </div>
    
    <!-- Search Tab -->
    <div id="search-tab" class="tab-content active">
      <!-- Configuration Section -->
      <div class="section" id="config-section">
        <h2>Quick Configuration</h2>
        
        <!-- CORS Warning -->
        <div id="cors-warning" style="display:none;">
          <strong>‚ö†Ô∏è Local File Detected</strong><br>
          <p style="margin:5px 0;">This tool needs to be hosted online. Quick solutions:</p>
          <ol style="margin:5px 0 5px 20px;">
            <li><strong>GitHub Pages</strong>: Upload to GitHub, enable Pages</li>
            <li><strong>Python Server</strong>: Run <code>python -m http.server 8000</code></li>
            <li><strong>VS Code</strong>: Use Live Server extension</li>
          </ol>
        </div>
        
        <!-- API Key Input -->
        <label for="api-key">OpenAI API Key:</label><br>
        <input type="password" id="api-key" placeholder="Enter your OpenAI API key (sk-...)" size="50" />
        <button id="test-api-btn" class="secondary-button" style="margin-left: 10px;">Test API Key</button>
        <div id="api-test-result"></div>
        
        <!-- Model Selection -->
        <label for="model-select">AI Model:</label>
        <select id="model-select" style="margin-left: 10px;">
          <option value="gpt-4-turbo">GPT-4 Turbo</option>
          <option value="gpt-4o">GPT-4o</option>
          <option value="gpt-4o-mini">GPT-4o Mini (Cheaper)</option>
          <option value="gpt-4">GPT-4</option>
          <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Cheapest)</option>
        </select>
        
        <!-- Token Display -->
        <div class="token-display" id="token-display">
          üî§ Tokens - In: 0 | Out: 0 | Cost: $0.00
        </div>
      </div>

      <!-- Query Section -->
      <div class="section" id="query-section">
        <h2>Research Query</h2>
        <label for="query-input">Enter your medical research question:</label><br>
        <input type="text" id="query-input" size="80" placeholder="e.g. 'effects of metformin on diabetes prevention in prediabetic patients'" 
               style="width: 100%; font-size: 16px; padding: 10px;" />
        
        <!-- PubMed Syntax Help -->
        <div class="syntax-help">
          <h4>üìö PubMed Search Syntax Quick Reference:</h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
            <div>
              <strong>Field Tags:</strong><br>
              <span class="syntax-example">[tiab]</span> = Title/Abstract<br>
              <span class="syntax-example">[ti]</span> = Title only<br>
              <span class="syntax-example">[au]</span> = Author<br>
              <span class="syntax-example">[MeSH]</span> = MeSH term
            </div>
            <div>
              <strong>Boolean Operators:</strong><br>
              <span class="syntax-example">AND</span> = Both terms<br>
              <span class="syntax-example">OR</span> = Either term<br>
              <span class="syntax-example">NOT</span> = Exclude term<br>
              <span class="syntax-example">( )</span> = Group terms
            </div>
            <div>
              <strong>Wildcards:</strong><br>
              <span class="syntax-example">*</span> = Any characters<br>
              <span class="syntax-example">"..."</span> = Exact phrase<br>
              Example: <span class="syntax-example">cell*</span> finds cells, cellular
            </div>
          </div>
        </div>
        
        <h3>Search Parameters</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <div>
            <label for="iterations">Iterations:</label>
            <input type="number" id="iterations" value="4" min="2" max="8" style="width:60px;" />
          </div>
          
          <div>
            <label for="articles-per-iter">Articles per iteration:</label>
            <input type="number" id="articles-per-iter" value="20" min="10" max="50" style="width:60px;" />
          </div>
          
          <div>
            <label for="top-articles">Top articles to analyze:</label>
            <input type="number" id="top-articles" value="8" min="3" max="15" style="width:60px;" />
          </div>
          
          <div>
            <label for="search-strategy">Search Strategy:</label>
            <select id="search-strategy">
              <option value="broad-to-narrow" selected>Broad ‚Üí Narrow</option>
              <option value="focused">Focused</option>
              <option value="exploratory">Exploratory</option>
            </select>
          </div>
        </div>
        
        <button id="start-btn" class="primary-button" style="margin-top: 20px;">
          üîç Start Iterative Search
        </button>
        <button id="cancel-btn" class="primary-button danger-button" style="display:none;">
          ‚ùå Cancel Search
        </button>
        <span id="progress-status"></span>
      </div>

      <!-- Progress Log Section -->
      <div class="section" id="log-section">
        <h2>Search Progress</h2>
        <div id="iteration-log" class="output-area" aria-live="polite"></div>
      </div>
    </div>
    
    <!-- Results Tab -->
    <div id="results-tab" class="tab-content">
      <div class="section" id="results-section">
        <h2>Top Articles with Abstracts</h2>
        <div id="results" class="output-area"></div>
        
        <h3>AI Summary of Top Articles</h3>
        <div style="margin: 10px 0;">
          <label for="summary-count">Summarize top</label>
          <input type="number" id="summary-count" value="5" min="3" max="15" style="width:50px;" /> articles
          <button id="summary-btn" class="secondary-button" style="margin-left: 10px;">Generate Summary</button>
        </div>
        <div id="summary" class="output-area"></div>
      </div>
    </div>
    
    <!-- Evolution Tab -->
    <div id="evolution-tab" class="tab-content">
      <div class="section" id="evolution-section">
        <h2>Search Evolution Overview</h2>
        <div id="evolution" class="output-area"></div>
        
        <h3>Complete Article Rankings</h3>
        <div id="rankings" class="output-area"></div>
      </div>
    </div>
    
    <!-- Prompts Tab -->
    <div id="prompts-tab" class="tab-content">
      <div class="section">
        <h2>‚ö†Ô∏è Prompt Customization</h2>
        <div class="warning-box">
          <strong>Warning:</strong> These prompts have been carefully designed for optimal performance. 
          Modify only if you understand the implications. Use [[term]] syntax for clean AI responses.
        </div>
        
        <!-- Search Terms Generation -->
        <div class="prompt-section">
          <div class="prompt-title">Initial Search Terms Prompt</div>
          <textarea id="prompt-initial-search" class="prompt-editor">You are a medical research expert. Generate PubMed search strategies for: "{query}"

IMPORTANT: Return search terms wrapped in [[brackets]] to ensure clean parsing.

Create 5 search strategies:
1. BROAD: General terms with high recall
2. FOCUSED: Specific combination of key terms  
3. MESH-HEAVY: Primarily MeSH terms
4. SYNONYM-BASED: Alternative terminology
5. METHODOLOGICAL: Focus on experimental methods

Use proper PubMed syntax ([tiab], [MeSH], AND, OR, parentheses).
Keep searches simple and effective - avoid long phrases.

YOU MUST FORMAT YOUR RESPONSE EXACTLY LIKE THIS:
1. BROAD: [[term1 AND term2 AND term3]]
2. FOCUSED: [[specific_term[tiab] AND "exact phrase" AND term]]
3. MESH-HEAVY: [["MeSH Term 1"[MeSH] AND "MeSH Term 2"[MeSH]]]
4. SYNONYM-BASED: [[(term1 OR synonym1) AND (term2 OR synonym2)]]
5. METHODOLOGICAL: [[method_term AND experimental AND model]]

Example response:
1. BROAD: [[metformin AND diabetes AND prevention]]
2. FOCUSED: [["diabetes prevention"[tiab] AND prediabetic AND treatment]]
3. MESH-HEAVY: [["Metformin"[MeSH] AND "Diabetes Mellitus"[MeSH]]]
4. SYNONYM-BASED: [[(metformin OR biguanide) AND (diabetes OR "type 2 diabetes")]]
5. METHODOLOGICAL: [[clinical trial AND randomized AND glucose control]]

Generate 5 searches:</textarea>
        </div>
        
        <!-- Refined Search Terms -->
        <div class="prompt-section">
          <div class="prompt-title">Refined Search Terms Prompt</div>
          <textarea id="prompt-refined-search" class="prompt-editor">Based on previous iterations, generate improved PubMed searches for: "{query}"

Previous context:
{context}

Learn from what worked:
- High-scoring articles used terms: {successful_terms}
- Failed searches: {failed_searches}

IMPORTANT: Return search terms wrapped in [[brackets]].

Generate 5 NEW search strategies that:
1. Avoid previous failures
2. Build on successful terms
3. Try new combinations
4. Explore related concepts
5. Adjust specificity based on results

Example response:
1. [[(metformin OR biguanide) AND "diabetes prevention" AND clinical trial]]
2. [[prediabetes[tiab] AND (intervention OR treatment) AND glucose]]</textarea>
        </div>
        
        <!-- Article Analysis -->
        <div class="prompt-section">
          <div class="prompt-title">Article Analysis Prompt</div>
          <textarea id="prompt-article-analysis" class="prompt-editor">Analyze these articles for relevance to: "{query}"

For each article, provide:
- Relevance score (0-100)
- Brief reasoning

Focus on:
1. Direct relevance to research question
2. Methodological alignment
3. Key findings related to query

Articles:
{articles}

IMPORTANT: Return structured data with scores in [[brackets]].

Example response:
Article 1: [[85]] - Directly studies Pard3 in corneal tissue...
Article 2: [[45]] - Related to cell polarity but different tissue...</textarea>
        </div>
        
        <!-- MeSH Validation -->
        <div class="prompt-section">
          <div class="prompt-title">MeSH Term Extraction</div>
          <textarea id="prompt-mesh-extraction" class="prompt-editor">Extract potential MeSH terms from this query: "{query}"

Return ONLY the MeSH terms wrapped in [[brackets]], one per line.
Include both exact MeSH headings and potential MeSH terms to verify.

Example for "diabetes kidney disease":
[[Diabetes Mellitus]]
[[Diabetic Nephropathies]]  
[[Kidney Diseases]]
[[Renal Insufficiency, Chronic]]</textarea>
        </div>
        
        <button onclick="savePrompts()" class="success-button">Save Custom Prompts</button>
        <button onclick="resetPrompts()" class="warning-button">Reset to Defaults</button>
      </div>
    </div>
    
    <!-- Configuration Tab -->
    <div id="config-tab" class="tab-content">
      <div class="section">
        <h2>Advanced Settings</h2>
        
        <h3>Search Behavior</h3>
        <label>
          <input type="checkbox" id="validate-mesh" checked> 
          Validate MeSH terms before searching
        </label><br>
        
        <label>
          <input type="checkbox" id="show-mesh-feedback" checked> 
          Show MeSH validation feedback
        </label><br>
        
        <label>
          <input type="checkbox" id="start-broad" checked> 
          Start with broad searches (recommended)
        </label><br>
        
        <label>
          <input type="checkbox" id="use-wildcards" checked> 
          Use wildcards for term variations (e.g., cell* for cells, cellular)
        </label><br>
        
        <h3>Result Processing</h3>
        <label for="min-relevance">Minimum relevance score to display:</label>
        <input type="number" id="min-relevance" value="30" min="0" max="100" style="width:60px;" /><br>
        
        <label for="rate-limit">API rate limit delay (ms):</label>
        <input type="number" id="rate-limit" value="400" min="100" max="2000" style="width:80px;" /><br>
        
        <h3>Export Options</h3>
        <button onclick="exportResults('json')" class="secondary-button">Export as JSON</button>
        <button onclick="exportResults('csv')" class="secondary-button">Export as CSV</button>
        <button onclick="exportResults('txt')" class="secondary-button">Export as Text</button>
        <button onclick="exportResults('bibtex')" class="secondary-button">Export as BibTeX</button>
      </div>
    </div>
  </div>

  <script>
    // ========== Global State Management ==========
    let state = {
      config: {},
      searchState: {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        meshTermsValidated: {},
        searchHistory: [],
        successfulTerms: new Set(),
        failedSearches: []
      },
      abortController: null,
      currentTab: 'search',
      customPrompts: {}
    };

    // ========== Default Prompt Templates ==========
    const DEFAULT_PROMPTS = {
      INITIAL_SEARCH: document.getElementById('prompt-initial-search').value,
      REFINED_SEARCH: document.getElementById('prompt-refined-search').value,
      ARTICLE_ANALYSIS: document.getElementById('prompt-article-analysis').value,
      MESH_EXTRACTION: document.getElementById('prompt-mesh-extraction').value,
      
      ITERATION_INSIGHTS: `Analyze iteration {iteration} for query: "{query}"

Results: {found_count} articles found
Top scoring: {top_score}
Search terms used: {search_terms}

Provide insights:
1. What worked well?
2. What didn't work?
3. Suggested improvements

Keep it concise and actionable.`,

      FINAL_RANKING: `Rank all {count} articles for query: "{query}"

Consider relevance, methodology, and direct applicability.

Return article numbers in order of relevance wrapped in [[brackets]]:
Example: [[3]] [[1]] [[7]] [[2]] [[5]]...`,

      SEARCH_SUMMARY: `Summarize the search evolution for: "{query}"

Total articles: {total}
Iterations: {iterations}
Best strategies: {best_strategies}

Provide a concise overview of the search process and key findings.`,

      ABSTRACT_SUMMARY: `Analyze and synthesize these research articles:

{abstracts}

Provide:
1. KEY FINDINGS: Main discoveries
2. METHODS: Common approaches
3. CLINICAL RELEVANCE: Practical implications
4. GAPS: What's missing

Keep it comprehensive yet accessible.`
    };

    // Load custom prompts or use defaults
    function loadPrompts() {
      const saved = localStorage.getItem('pubmedToolPrompts');
      if (saved) {
        state.customPrompts = JSON.parse(saved);
        // Update textareas
        Object.keys(state.customPrompts).forEach(key => {
          const element = document.getElementById(`prompt-${key.toLowerCase().replace(/_/g, '-')}`);
          if (element) element.value = state.customPrompts[key];
        });
      }
    }

    // Save custom prompts
    function savePrompts() {
      state.customPrompts = {
        INITIAL_SEARCH: document.getElementById('prompt-initial-search').value,
        REFINED_SEARCH: document.getElementById('prompt-refined-search').value,
        ARTICLE_ANALYSIS: document.getElementById('prompt-article-analysis').value,
        MESH_EXTRACTION: document.getElementById('prompt-mesh-extraction').value
      };
      localStorage.setItem('pubmedToolPrompts', JSON.stringify(state.customPrompts));
      alert('Custom prompts saved successfully!');
    }

    // Reset prompts to defaults
    function resetPrompts() {
      if (confirm('Reset all prompts to defaults?')) {
        document.getElementById('prompt-initial-search').value = DEFAULT_PROMPTS.INITIAL_SEARCH;
        document.getElementById('prompt-refined-search').value = DEFAULT_PROMPTS.REFINED_SEARCH;
        document.getElementById('prompt-article-analysis').value = DEFAULT_PROMPTS.ARTICLE_ANALYSIS;
        document.getElementById('prompt-mesh-extraction').value = DEFAULT_PROMPTS.MESH_EXTRACTION;
        localStorage.removeItem('pubmedToolPrompts');
        state.customPrompts = {};
        alert('Prompts reset to defaults!');
      }
    }

    // ========== Token Counter ==========
    class TokenCounter {
      constructor() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
      
      estimateTokens(text) {
        // Rough estimate: ~1 token per 4 characters
        return Math.ceil(text.length / 4);
      }
      
      addApiCall(prompt, response) {
        this.inputTokens += this.estimateTokens(prompt);
        this.outputTokens += this.estimateTokens(response);
        updateTokenDisplay();
      }
      
      getCostEstimate(model = "gpt-4-turbo") {
        const pricing = {
          "gpt-4-turbo": { input: 0.01, output: 0.03 },
          "gpt-4o": { input: 0.005, output: 0.015 },
          "gpt-4o-mini": { input: 0.00015, output: 0.0006 },
          "gpt-4": { input: 0.03, output: 0.06 },
          "gpt-3.5-turbo": { input: 0.0005, output: 0.0015 }
        };
        
        const modelPricing = pricing[model] || pricing["gpt-4-turbo"];
        const inputCost = (this.inputTokens / 1000) * modelPricing.input;
        const outputCost = (this.outputTokens / 1000) * modelPricing.output;
        
        return inputCost + outputCost;
      }
      
      reset() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
    }

    const tokenCounter = new TokenCounter();

    // ========== Core Configuration ==========
    const CORS_PROXIES = [
      'https://corsproxy.io/?',
      'https://api.codetabs.com/v1/proxy?quest=',
      'https://api.allorigins.win/raw?url='
    ];
    let currentProxyIndex = 0;
    
    // ========== Helper Functions ==========
    
    // Tab management
    function showTab(tabName) {
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.getElementById(`${tabName}-tab`).classList.add('active');
      event.target.classList.add('active');
      state.currentTab = tabName;
    }

    // Parse bracketed terms from AI response - with better fallback
    function parseBracketedTerms(text) {
      // First try to find [[term]] format
      const matches = text.match(/\[\[([^\]]+)\]\]/g);
      if (matches && matches.length > 0) {
        return matches.map(match => match.replace(/\[\[|\]\]/g, '').trim());
      }
      
      // Fallback: Look for numbered lists
      const lines = text.split('\n');
      const searches = [];
      
      for (const line of lines) {
        // Match patterns like "1. search term" or "BROAD: search term"
        const numbered = line.match(/^\d+\.\s*(.+)/);
        const labeled = line.match(/^(?:BROAD|FOCUSED|MESH-HEAVY|SYNONYM-BASED|METHODOLOGICAL):\s*(.+)/i);
        
        if (numbered) {
          searches.push(numbered[1].trim());
        } else if (labeled) {
          searches.push(labeled[1].trim());
        }
      }
      
      // If still nothing found, try to extract any line that looks like a search
      if (searches.length === 0) {
        for (const line of lines) {
          const trimmed = line.trim();
          // Check if line contains AND, OR, or PubMed syntax
          if (trimmed && (trimmed.includes(' AND ') || trimmed.includes(' OR ') || 
              trimmed.includes('[') || trimmed.includes('"'))) {
            searches.push(trimmed);
          }
        }
      }
      
      return searches;
    }

    // Enhanced logging
    function logMessage(message, isHtml = false) {
      const logArea = document.getElementById("iteration-log");
      const timestamp = new Date().toLocaleTimeString();
      
      if (isHtml) {
        logArea.innerHTML += `[${timestamp}] ${message}`;
      } else {
        logArea.textContent += `[${timestamp}] ${message}`;
      }
      logArea.scrollTop = logArea.scrollHeight;
    }

    // Update token display
    function updateTokenDisplay() {
      const cost = tokenCounter.getCostEstimate(state.config.modelChoice);
      document.getElementById("token-display").textContent = 
        `üî§ Tokens - In: ${tokenCounter.inputTokens.toLocaleString()} | Out: ${tokenCounter.outputTokens.toLocaleString()} | Cost: $${cost.toFixed(4)}`;
    }

    // ========== API Functions ==========
    
    // OpenAI API call
    async function callOpenAI(prompt, temperature = 0.3, maxTokens = 1000) {
      const requestBody = {
        model: state.config.modelChoice,
        messages: [{ role: "user", content: prompt }],
        temperature: temperature,
        max_tokens: maxTokens
      };
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${state.config.openAIKey}`
          },
          body: JSON.stringify(requestBody),
          signal: state.abortController?.signal
        });
        
        const responseText = await response.text();
        
        if (!response.ok) {
          let errorMessage = `OpenAI API Error: ${response.status}`;
          try {
            const errorData = JSON.parse(responseText);
            if (errorData.error?.message) {
              errorMessage = errorData.error.message;
            }
          } catch (e) {}
          throw new Error(errorMessage);
        }
        
        const data = JSON.parse(responseText);
        const text = data.choices[0].message.content.trim();
        
        tokenCounter.addApiCall(prompt, text);
        
        return text;
      } catch (error) {
        if (error.name === 'AbortError') {
          logMessage("‚ùå API call cancelled.\n");
        } else {
          logMessage(`‚ùå API Error: ${error.message}\n`);
        }
        throw error;
      }
    }

    // Extract MeSH terms from query
    async function extractMeshTerms(query) {
      const prompt = getPrompt('MESH_EXTRACTION').replace("{query}", query);
      
      try {
        const response = await callOpenAI(prompt, 0.2, 300);
        return parseBracketedTerms(response);
      } catch (e) {
        logMessage(`‚ö†Ô∏è MeSH extraction failed: ${e.message}\n`);
        return [];
      }
    }

    // Validate MeSH term
    async function validateMeshTerm(term) {
      // Check cache first
      if (state.searchState.meshTermsValidated[term] !== undefined) {
        return state.searchState.meshTermsValidated[term];
      }
      
      const url = `https://id.nlm.nih.gov/mesh/lookup/descriptor?label=${encodeURIComponent(term)}&match=exact&limit=1`;
      
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) return false;
        
        const data = await resp.json();
        const isValid = Array.isArray(data) && data.length > 0 && data[0].label === term;
        
        // Cache result
        state.searchState.meshTermsValidated[term] = isValid;
        
        return isValid;
      } catch (error) {
        console.warn("MeSH verification error:", error);
        return false;
      }
    }

    // Enhanced fetch with CORS proxy
    async function cancellableFetch(url, options = {}) {
      let lastError;
      
      // Try direct fetch first for non-NCBI URLs
      if (!url.includes('ncbi.nlm.nih.gov')) {
        try {
          const response = await fetch(url, { ...options, signal: state.abortController?.signal });
          if (response.ok) return response;
        } catch (e) {}
      }
      
      // Try CORS proxies
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
        const proxy = CORS_PROXIES[proxyIndex];
        const proxiedUrl = proxy + encodeURIComponent(url);
        
        try {
          const response = await fetch(proxiedUrl, { ...options, signal: state.abortController?.signal });
          if (response.ok) {
            currentProxyIndex = proxyIndex;
            return response;
          }
          lastError = new Error(`Proxy returned ${response.status}`);
        } catch (error) {
          lastError = error;
          if (error.name === 'AbortError') throw error;
        }
      }
      
      throw lastError || new Error('All CORS proxies failed');
    }

    // Search PubMed
    async function searchPubMed(query, maxResults = 20) {
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(query)}&retmode=xml&retmax=${maxResults}&tool=AI_PubMed_Tool&email=tool@example.com&sort=relevance`;
      
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) throw new Error(`PubMed error: ${resp.status}`);
        
        const xmlText = await resp.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "text/xml");
        
        const errorNode = xmlDoc.querySelector("ERROR");
        if (errorNode) {
          throw new Error(`PubMed API: ${errorNode.textContent}`);
        }
        
        const idElements = Array.from(xmlDoc.getElementsByTagName("Id"));
        return idElements.map(idNode => idNode.textContent);
      } catch (error) {
        if (error.name !== 'AbortError') {
          logMessage(`‚ùå PubMed search error: ${error.message}\n`);
        }
        return [];
      }
    }

    // Fetch article details
    async function fetchPubMedDetails(pmids) {
      if (pmids.length === 0) return [];
      
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${pmids.join(",")}&retmode=xml&tool=AI_PubMed_Tool&email=tool@example.com`;
      
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) throw new Error(`PubMed fetch error: ${resp.status}`);
        
        const xmlText = await resp.text();
        const xmlDoc = new DOMParser().parseFromString(xmlText, "text/xml");
        const articleNodes = Array.from(xmlDoc.getElementsByTagName("PubmedArticle"));
        
        return articleNodes.map(parseArticleXML);
      } catch (error) {
        if (error.name !== 'AbortError') {
          logMessage(`‚ùå Fetch error: ${error.message}\n`);
        }
        return [];
      }
    }

    // Parse article XML
    function parseArticleXML(articleNode) {
      function textOrDefault(elem, tag, defaultVal = "") {
        const node = elem.getElementsByTagName(tag)[0];
        return node && node.textContent ? node.textContent : defaultVal;
      }
      
      const pmid = textOrDefault(articleNode, "PMID", "Unknown");
      const title = textOrDefault(articleNode, "ArticleTitle", "No Title");
      
      const authors = Array.from(articleNode.getElementsByTagName("Author")).map(auth => {
        const lastName = textOrDefault(auth, "LastName");
        const foreName = textOrDefault(auth, "ForeName");
        return lastName ? (foreName ? `${lastName}, ${foreName}` : lastName) : null;
      }).filter(Boolean);
      
      const journal = textOrDefault(articleNode, "Title", "Unknown Journal");
      
      const pubDateNode = articleNode.getElementsByTagName("PubDate")[0];
      let pubYear = "Unknown";
      if (pubDateNode) {
        pubYear = textOrDefault(pubDateNode, "Year") || 
                  textOrDefault(pubDateNode, "MedlineDate", "Unknown").substring(0, 4);
      }
      
      const abstractTexts = Array.from(articleNode.getElementsByTagName("AbstractText"))
        .map(node => {
          const label = node.getAttribute("Label");
          return label ? `${label}: ${node.textContent}` : node.textContent;
        })
        .join(" ");
      
      return {
        pmid,
        title,
        authors,
        journal,
        pub_date: pubYear,
        abstract: abstractTexts.trim(),
        relevance_score: 0,
        ai_reasoning: "",
        found_in_iteration: 0
      };
    }

    // Get appropriate prompt
    function getPrompt(key) {
      // Check custom prompts first
      if (state.customPrompts[key]) {
        return state.customPrompts[key];
      }
      
      // Check textarea values for dynamic prompts
      const elementId = `prompt-${key.toLowerCase().replace(/_/g, '-')}`;
      const element = document.getElementById(elementId);
      if (element) {
        return element.value;
      }
      
      // Fall back to defaults
      return DEFAULT_PROMPTS[key] || '';
    }

    // Generate initial search terms
    async function generateInitialSearchTerms(query) {
      logMessage("\nüîç Generating initial search strategies...\n");
      logMessage("   Strategy: Starting broad, then focusing on specific aspects\n");
      
      const prompt = getPrompt('INITIAL_SEARCH').replace("{query}", query);
      
      try {
        const response = await callOpenAI(prompt, 0.3, 600);
        
        // Log the AI's response for transparency
        logMessage("\nüìù AI Response:\n");
        logMessage("---\n" + response + "\n---\n\n");
        
        const searches = parseBracketedTerms(response);
        
        if (searches.length === 0) {
          throw new Error("No valid search terms extracted from AI response");
        }
        
        return searches;
      } catch (e) {
        logMessage(`‚ö†Ô∏è Failed to generate searches: ${e.message}\n`);
        logMessage("   Using fallback search strategy...\n");
        
        // Better fallback: create meaningful searches
        const terms = query.match(/\b\w+\b/g) || [];
        const keyTerms = terms.filter(t => t.length > 3 && !['and', 'the', 'for', 'with', 'show'].includes(t.toLowerCase()));
        
        return [
          // Broad: all key terms with AND
          keyTerms.join(' AND '),
          // Focused: first few key terms
          keyTerms.slice(0, 3).join(' AND '),
          // With wildcards
          keyTerms.slice(0, 2).map(t => t + '*').join(' AND '),
          // Alternative: key terms in title/abstract
          keyTerms.slice(0, 2).map(t => t + '[tiab]').join(' AND '),
          // Just the main terms
          keyTerms.slice(0, 2).join(' ')
        ].filter(s => s.length > 0).slice(0, 5);
      }
    }

    // Generate refined search terms
    async function generateRefinedSearchTerms(query, iteration) {
      logMessage("\nüîÑ Generating refined search strategies...\n");
      logMessage("   Strategy: Learning from successful searches and avoiding failures\n");
      
      // Build context from history
      const context = buildSearchContext();
      const successfulTerms = Array.from(state.searchState.successfulTerms).slice(0, 5).join(", ");
      const failedSearches = state.searchState.failedSearches.slice(-5).join("; ");
      
      const prompt = getPrompt('REFINED_SEARCH')
        .replace("{query}", query)
        .replace("{context}", context)
        .replace("{successful_terms}", successfulTerms || "none yet")
        .replace("{failed_searches}", failedSearches || "none");
      
      try {
        const response = await callOpenAI(prompt, 0.4, 600);
        
        // Log the AI's response
        logMessage("\nüìù AI Refined Response:\n");
        logMessage("---\n" + response + "\n---\n\n");
        
        const searches = parseBracketedTerms(response);
        
        if (searches.length === 0) {
          throw new Error("No valid search terms extracted");
        }
        
        return searches;
      } catch (e) {
        logMessage(`‚ö†Ô∏è Failed to refine searches: ${e.message}\n`);
        logMessage("   Using alternative search strategy...\n");
        
        // Better fallback for refined searches
        const terms = query.match(/\b\w+\b/g) || [];
        const keyTerms = terms.filter(t => t.length > 3 && !['and', 'the', 'for', 'with', 'show'].includes(t.toLowerCase()));
        
        // Try variations based on what we've learned
        const refinedSearches = [];
        
        // If we have successful terms, modify them slightly
        if (state.searchState.successfulTerms.size > 0) {
          const successful = Array.from(state.searchState.successfulTerms);
          successful.slice(0, 2).forEach(term => {
            // Add wildcards to successful terms
            refinedSearches.push(term.replace(/(\w{4,})/g, '$1*'));
          });
        }
        
        // Add new combinations
        refinedSearches.push(
          // Try with field tags
          keyTerms.slice(0, 3).map(t => t + '[tiab]').join(' AND '),
          // Try with fewer terms
          keyTerms.slice(0, 2).join(' AND '),
          // Try with "OR" for flexibility
          `(${keyTerms[0]} OR ${keyTerms[1]}) AND ${keyTerms[2] || keyTerms[1]}`
        );
        
        return refinedSearches.filter(s => s && s.length > 0).slice(0, 5);
      }
    }

    // Build search context
    function buildSearchContext() {
      let context = "";
      
      state.searchState.iterationsData.slice(-2).forEach(iter => {
        context += `\nIteration ${iter.number}:\n`;
        context += `- Articles found: ${iter.articlesFound}\n`;
        context += `- Best score: ${iter.bestScore || 0}\n`;
        context += `- Working terms: ${iter.workingTerms.join(", ")}\n`;
      });
      
      return context;
    }

    // Analyze articles with AI
    async function analyzeArticles(query, articles) {
      if (articles.length === 0) return [];
      
      logMessage("ü§ñ Analyzing articles for relevance...\n");
      
      const articleInfo = articles.map((a, i) => ({
        index: i + 1,
        title: a.title,
        abstract: a.abstract ? a.abstract.substring(0, 500) + "..." : "No abstract",
        journal: a.journal,
        year: a.pub_date
      }));
      
      const prompt = getPrompt('ARTICLE_ANALYSIS')
        .replace("{query}", query)
        .replace("{articles}", JSON.stringify(articleInfo, null, 2));
      
      try {
        const response = await callOpenAI(prompt, 0.2, 1500);
        
        // Parse scores from response
        const lines = response.split('\n');
        lines.forEach(line => {
          const scoreMatch = line.match(/Article (\d+):\s*\[\[(\d+)\]\]/);
          if (scoreMatch) {
            const index = parseInt(scoreMatch[1]) - 1;
            const score = parseInt(scoreMatch[2]);
            const reasoning = line.split('-').slice(1).join('-').trim();
            
            if (articles[index]) {
              articles[index].relevance_score = score;
              articles[index].ai_reasoning = reasoning || "Relevance assessed";
            }
          }
        });
        
      } catch (e) {
        logMessage(`‚ö†Ô∏è Analysis failed: ${e.message}. Using fallback scoring.\n`);
        articles.forEach(a => {
          a.relevance_score = 50;
          a.ai_reasoning = "AI analysis unavailable";
        });
      }
      
      return articles;
    }

    // Display and validate search terms
    async function displaySearchTerms(searchTerms, iteration) {
      logMessage(`\nüìã Search strategies for iteration ${iteration}:\n`);
      
      // Add labels for clarity
      const labels = ['BROAD', 'FOCUSED', 'MESH-HEAVY', 'SYNONYM-BASED', 'METHODOLOGICAL'];
      
      for (let i = 0; i < searchTerms.length; i++) {
        const term = searchTerms[i];
        const label = labels[i] || `Strategy ${i + 1}`;
        
        // Start with the label
        let displayLine = `${i + 1}. ${label}: `;
        
        // Extract and validate MeSH terms if enabled
        if (document.getElementById('validate-mesh').checked) {
          const meshMatches = [...term.matchAll(/"([^"]+)"\[MeSH\]/g)];
          let validatedTerm = term;
          
          if (meshMatches.length > 0) {
            for (const match of meshMatches) {
              const meshTerm = match[1];
              const isValid = await validateMeshTerm(meshTerm);
              
              if (document.getElementById('show-mesh-feedback').checked) {
                const status = isValid ? 
                  '<span class="mesh-valid">‚úì</span>' : 
                  '<span class="mesh-invalid">‚úó</span>';
                validatedTerm = validatedTerm.replace(
                  match[0],
                  match[0] + ' ' + status
                );
              }
              
              await new Promise(resolve => setTimeout(resolve, 50));
            }
          }
          
          displayLine += validatedTerm;
        } else {
          displayLine += term;
        }
        
        logMessage(`<div class="search-term">${displayLine}</div>`, true);
      }
      
      logMessage("\n");
    }

    // Main search function
    async function runIterativeSearch(query) {
      toggleUI(true);
      resetSearchState();
      state.abortController = new AbortController();
      
      clearAllDisplays();
      
      logMessage(`üöÄ Starting iterative search for: "${query}"\n`);
      logMessage("=" + "=".repeat(60) + "\n\n");
      
      try {
        // Extract potential MeSH terms first
        if (document.getElementById('validate-mesh').checked) {
          logMessage("üìö Extracting potential MeSH terms...\n");
          const meshTerms = await extractMeshTerms(query);
          if (meshTerms.length > 0) {
            logMessage(`Found potential MeSH terms: ${meshTerms.join(", ")}\n`);
          }
        }
        
        // Main iteration loop
        for (let iter = 1; iter <= state.config.totalIterations; iter++) {
          // Check for cancellation
          if (state.abortController.signal.aborted) {
            throw new Error("Search cancelled");
          }
          
          logMessage(`\n${"=".repeat(60)}\n`);
          logMessage(`üîÑ ITERATION ${iter} of ${state.config.totalIterations}\n`);
          logMessage(`${"=".repeat(60)}\n`);
          
          // Generate search terms
          let searchTerms;
          try {
            searchTerms = iter === 1 
              ? await generateInitialSearchTerms(query)
              : await generateRefinedSearchTerms(query, iter);
          } catch (error) {
            if (error.name === 'AbortError') {
              throw new Error("Search cancelled");
            }
            // If generation fails, try fallback
            logMessage(`‚ö†Ô∏è Search generation error: ${error.message}\n`);
            searchTerms = await generateInitialSearchTerms(query);
          }
          
          // Ensure we have valid search terms
          if (!searchTerms || searchTerms.length === 0) {
            logMessage("‚ùå No search terms generated. Skipping iteration.\n");
            continue;
          }
          
          // Display and validate search terms
          await displaySearchTerms(searchTerms, iter);
          
          // Execute searches
          logMessage("\nüîç Executing searches...\n");
          const allPmids = [];
          const articlesPerSearch = Math.ceil(state.config.articlesPerIteration / searchTerms.length);
          
          for (let i = 0; i < searchTerms.length; i++) {
            const term = searchTerms[i];
            logMessage(`  Search ${i + 1}: `);
            
            try {
              const pmids = await searchPubMed(term, articlesPerSearch + 5);
              allPmids.push(...pmids);
              
              if (pmids.length > 0) {
                logMessage(`‚úÖ Found ${pmids.length} articles\n`);
                state.searchState.successfulTerms.add(term);
              } else {
                logMessage(`‚ùå No results\n`);
                state.searchState.failedSearches.push(term);
              }
            } catch (searchError) {
              logMessage(`‚ùå Error: ${searchError.message}\n`);
              state.searchState.failedSearches.push(term);
            }
            
            // Rate limiting
            await new Promise(resolve => 
              setTimeout(resolve, parseInt(document.getElementById('rate-limit').value))
            );
          }
          
          // Process unique PMIDs
          const uniquePmids = [...new Set(allPmids)];
          logMessage(`\nüìä Total unique articles found: ${uniquePmids.length}\n`);
          
          if (uniquePmids.length === 0) {
            logMessage("‚ö†Ô∏è No articles found this iteration.\n");
            continue;
          }
          
          // Fetch new articles
          const newPmids = uniquePmids.filter(pmid => !state.searchState.allArticles[pmid]);
          if (newPmids.length > 0) {
            logMessage(`üì• Fetching details for ${newPmids.length} new articles...\n`);
            try {
              const newArticles = await fetchPubMedDetails(newPmids);
              
              newArticles.forEach(article => {
                article.found_in_iteration = iter;
                state.searchState.allArticles[article.pmid] = article;
              });
            } catch (fetchError) {
              logMessage(`‚ùå Error fetching article details: ${fetchError.message}\n`);
            }
          }
          
          // Get current iteration's articles
          const currentArticles = uniquePmids
            .map(pmid => state.searchState.allArticles[pmid])
            .filter(Boolean);
          
          // Analyze articles
          const analyzedArticles = await analyzeArticles(query, currentArticles);
          
          // Sort by relevance
          analyzedArticles.sort((a, b) => b.relevance_score - a.relevance_score);
          
          // Display top articles
          const topArticles = analyzedArticles.slice(0, state.config.topArticlesPerIteration);
          displayIterationResults(iter, topArticles);
          
          // Store iteration data
          const workingTerms = [];
          for (let i = 0; i < searchTerms.length; i++) {
            if (state.searchState.successfulTerms.has(searchTerms[i])) {
              workingTerms.push(searchTerms[i]);
            }
          }
          
          state.searchState.iterationsData.push({
            number: iter,
            searchTerms,
            articlesFound: uniquePmids.length,
            newArticles: newPmids.length,
            bestScore: topArticles[0]?.relevance_score || 0,
            topArticles,
            workingTerms
          });
        }
        
        // Finalize results
        await finalizeResults(query);
        
      } catch (error) {
        handleSearchError(error);
      } finally {
        toggleUI(false);
      }
    }

    // Display iteration results
    function displayIterationResults(iteration, topArticles) {
      logMessage(`\nüèÜ Top articles for iteration ${iteration}:\n`);
      
      const minScore = parseInt(document.getElementById('min-relevance').value);
      
      topArticles.slice(0, 3).forEach((article, i) => {
        if (article.relevance_score >= minScore) {
          const scoreClass = article.relevance_score >= 80 ? 'score-excellent' :
                           article.relevance_score >= 60 ? 'score-good' :
                           article.relevance_score >= 40 ? 'score-medium' : 'score-poor';
          
          logMessage(`\n${i + 1}. ${article.title}\n`);
          logMessage(`   <span class="${scoreClass}">Score: ${article.relevance_score}/100</span>\n`, true);
          logMessage(`   ${article.ai_reasoning}\n`);
        }
      });
    }

    // Finalize results
    async function finalizeResults(query) {
      const allArticles = Object.values(state.searchState.allArticles);
      
      if (allArticles.length === 0) {
        logMessage("\n‚ö†Ô∏è No articles found in the entire search.\n");
        return;
      }
      
      logMessage(`\n\n${"=".repeat(60)}\n`);
      logMessage(`üéØ FINALIZING RESULTS\n`);
      logMessage(`${"=".repeat(60)}\n`);
      
      // Final ranking
      const prompt = DEFAULT_PROMPTS.FINAL_RANKING
        .replace("{query}", query)
        .replace("{count}", allArticles.length);
      
      try {
        const response = await callOpenAI(prompt, 0.2, 500);
        const rankings = parseBracketedTerms(response);
        
        state.searchState.finalRanking = rankings
          .map(num => allArticles[parseInt(num) - 1])
          .filter(Boolean);
        
        // Add any missing articles
        const ranked = new Set(state.searchState.finalRanking);
        allArticles.forEach(article => {
          if (!ranked.has(article)) {
            state.searchState.finalRanking.push(article);
          }
        });
        
      } catch (e) {
        logMessage(`‚ö†Ô∏è Ranking failed: ${e.message}. Using score-based ranking.\n`);
        state.searchState.finalRanking = allArticles
          .sort((a, b) => b.relevance_score - a.relevance_score);
      }
      
      // Display results
      displayFinalResults();
      generateSearchSummary(query);
      
      logMessage("\n‚úÖ Search completed successfully!\n");
    }

    // Display final results
    function displayFinalResults() {
      const resultsDiv = document.getElementById("results");
      const topArticles = state.searchState.finalRanking.slice(0, 10);
      
      let html = '<h3>Top Articles</h3>\n';
      
      topArticles.forEach((article, i) => {
        const scoreClass = article.relevance_score >= 80 ? 'score-excellent' :
                         article.relevance_score >= 60 ? 'score-good' :
                         article.relevance_score >= 40 ? 'score-medium' : 'score-poor';
        
        html += `<div class="article-result">`;
        html += `<h4>#${i + 1}: ${escapeHtml(article.title)}</h4>`;
        html += `<div class="article-metadata">`;
        html += `<strong>Authors:</strong> ${article.authors.slice(0, 3).join(", ")}`;
        if (article.authors.length > 3) html += ` + ${article.authors.length - 3} more`;
        html += `<br><strong>Journal:</strong> ${escapeHtml(article.journal)} (${article.pub_date})`;
        html += `<br><strong>PMID:</strong> ${article.pmid}`;
        html += ` | <strong class="${scoreClass}">Score: ${article.relevance_score}/100</strong>`;
        html += ` | <strong>Found in iteration:</strong> ${article.found_in_iteration}`;
        html += `<br><strong>URL:</strong> <a href="https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/" target="_blank">View on PubMed</a>`;
        html += `<br><strong>AI Assessment:</strong> ${escapeHtml(article.ai_reasoning)}`;
        html += `</div>`;
        
        if (article.abstract) {
          html += `<div class="article-abstract">`;
          html += `<strong>Abstract:</strong><br>${escapeHtml(article.abstract)}`;
          html += `</div>`;
        }
        
        html += `</div>`;
      });
      
      resultsDiv.innerHTML = html;
      
      // Rankings
      const rankingsDiv = document.getElementById("rankings");
      let rankingsText = `COMPLETE ARTICLE RANKINGS\n${"=".repeat(50)}\n\n`;
      
      state.searchState.finalRanking.forEach((article, i) => {
        rankingsText += `${i + 1}. ${article.title}\n`;
        rankingsText += `   PMID: ${article.pmid} | Score: ${article.relevance_score} | Iteration: ${article.found_in_iteration}\n\n`;
      });
      
      rankingsDiv.textContent = rankingsText;
    }

    // Generate search summary
    async function generateSearchSummary(query) {
      const evolutionDiv = document.getElementById("evolution");
      
      let summaryText = `SEARCH EVOLUTION\n${"=".repeat(50)}\n\n`;
      summaryText += `Query: "${query}"\n`;
      summaryText += `Total iterations: ${state.searchState.iterationsData.length}\n`;
      summaryText += `Total unique articles: ${Object.keys(state.searchState.allArticles).length}\n`;
      summaryText += `Articles in final ranking: ${state.searchState.finalRanking.length}\n\n`;
      
      // Best strategies
      const bestStrategies = Array.from(state.searchState.successfulTerms).slice(0, 5);
      summaryText += `Most successful search strategies:\n`;
      bestStrategies.forEach((strategy, i) => {
        summaryText += `${i + 1}. ${strategy}\n`;
      });
      
      summaryText += `\nIteration breakdown:\n`;
      state.searchState.iterationsData.forEach(iter => {
        summaryText += `\nIteration ${iter.number}:\n`;
        summaryText += `  ‚Ä¢ Articles found: ${iter.articlesFound} (${iter.newArticles} new)\n`;
        summaryText += `  ‚Ä¢ Best score: ${iter.bestScore}\n`;
        summaryText += `  ‚Ä¢ Effective searches: ${iter.workingTerms.length}/${iter.searchTerms.length}\n`;
      });
      
      evolutionDiv.textContent = summaryText;
    }

    // Generate abstract summary
    async function generateAbstractSummary() {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results to summarize.");
        return;
      }
      
      const count = parseInt(document.getElementById("summary-count").value);
      const topArticles = state.searchState.finalRanking.slice(0, count);
      
      const summaryDiv = document.getElementById("summary");
      summaryDiv.textContent = "Generating summary...";
      
      let abstractsText = "";
      topArticles.forEach((article, i) => {
        abstractsText += `\nArticle ${i + 1}: ${article.title}\n`;
        abstractsText += `Authors: ${article.authors.slice(0, 3).join(", ")}\n`;
        abstractsText += `Journal: ${article.journal} (${article.pub_date})\n`;
        abstractsText += `Abstract: ${article.abstract || "Not available"}\n`;
        abstractsText += "-".repeat(80) + "\n";
      });
      
      const prompt = DEFAULT_PROMPTS.ABSTRACT_SUMMARY
        .replace("{abstracts}", abstractsText);
      
      try {
        const summary = await callOpenAI(prompt, 0.3, 1500);
        summaryDiv.textContent = summary;
      } catch (e) {
        summaryDiv.textContent = `Error: ${e.message}`;
      }
    }

    // Handle errors
    function handleSearchError(error) {
      if (error.name === 'AbortError' || error.message === 'Search cancelled') {
        logMessage("\n\n‚ùå Search cancelled by user.\n");
      } else {
        logMessage(`\n\n‚ùå Error: ${error.message}\n`);
      }
    }

    // Clear displays
    function clearAllDisplays() {
      ['iteration-log', 'results', 'summary', 'evolution', 'rankings'].forEach(id => {
        document.getElementById(id).textContent = '';
      });
    }

    // Reset search state
    function resetSearchState() {
      state.searchState = {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        meshTermsValidated: {},
        searchHistory: [],
        successfulTerms: new Set(),
        failedSearches: []
      };
      tokenCounter.reset();
      updateTokenDisplay();
    }

    // Toggle UI
    function toggleUI(isSearching) {
      document.getElementById("start-btn").disabled = isSearching;
      document.getElementById("start-btn").style.display = isSearching ? 'none' : 'inline-block';
      document.getElementById("cancel-btn").style.display = isSearching ? 'inline-block' : 'none';
      
      const inputs = document.querySelectorAll('input:not(#test-api-btn), select, textarea');
      inputs.forEach(el => el.disabled = isSearching);
    }

    // Export results
    function exportResults(format) {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results to export.");
        return;
      }
      
      let content = '';
      let filename = `pubmed_results_${new Date().toISOString().split('T')[0]}`;
      let mimeType = 'text/plain';
      
      if (format === 'json') {
        content = JSON.stringify({
          query: document.getElementById("query-input").value,
          date: new Date().toISOString(),
          results: state.searchState.finalRanking,
          searchHistory: state.searchState.searchHistory,
          tokenUsage: {
            input: tokenCounter.inputTokens,
            output: tokenCounter.outputTokens,
            cost: tokenCounter.getCostEstimate(state.config.modelChoice)
          }
        }, null, 2);
        filename += '.json';
        mimeType = 'application/json';
      } else if (format === 'csv') {
        content = 'Rank,PMID,Title,Authors,Journal,Year,Score,URL\n';
        state.searchState.finalRanking.forEach((article, i) => {
          content += `${i + 1},`;
          content += `"${article.pmid}",`;
          content += `"${article.title.replace(/"/g, '""')}",`;
          content += `"${article.authors.slice(0, 3).join('; ')}",`;
          content += `"${article.journal.replace(/"/g, '""')}",`;
          content += `${article.pub_date},`;
          content += `${article.relevance_score},`;
          content += `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n`;
        });
        filename += '.csv';
        mimeType = 'text/csv';
      } else if (format === 'bibtex') {
        state.searchState.finalRanking.forEach((article, i) => {
          content += `@article{pmid${article.pmid},\n`;
          content += `  title={${article.title}},\n`;
          content += `  author={${article.authors.join(' and ')}},\n`;
          content += `  journal={${article.journal}},\n`;
          content += `  year={${article.pub_date}},\n`;
          content += `  pmid={${article.pmid}}\n`;
          content += `}\n\n`;
        });
        filename += '.bib';
        mimeType = 'text/plain';
      } else {
        // Text format
        content = `PUBMED SEARCH RESULTS\n`;
        content += `${"=".repeat(60)}\n\n`;
        content += `Query: ${document.getElementById("query-input").value}\n`;
        content += `Date: ${new Date().toLocaleString()}\n`;
        content += `Total Results: ${state.searchState.finalRanking.length}\n\n`;
        
        state.searchState.finalRanking.forEach((article, i) => {
          content += `${i + 1}. ${article.title}\n`;
          content += `   Authors: ${article.authors.join(', ')}\n`;
          content += `   Journal: ${article.journal} (${article.pub_date})\n`;
          content += `   PMID: ${article.pmid}\n`;
          content += `   Score: ${article.relevance_score}/100\n`;
          content += `   URL: https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n`;
          content += `   Abstract: ${article.abstract || 'Not available'}\n`;
          content += `\n${"-".repeat(60)}\n\n`;
        });
        
        filename += '.txt';
      }
      
      // Download
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Test API key
    async function testAPIKey() {
      const apiKey = document.getElementById("api-key").value.trim();
      const resultDiv = document.getElementById("api-test-result");
      
      if (!apiKey) {
        resultDiv.innerHTML = '<div class="api-test-result api-test-failure">‚ùå Please enter an API key</div>';
        return;
      }
      
      resultDiv.innerHTML = '<div class="api-test-result">Testing API key...</div>';
      
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          method: "GET",
          headers: {
            "Authorization": `Bearer ${apiKey}`
          }
        });
        
        if (response.ok) {
          resultDiv.innerHTML = '<div class="api-test-result api-test-success">‚úÖ API key is valid!</div>';
        } else {
          const error = await response.json().catch(() => ({ error: { message: "Invalid key" } }));
          resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå ${error.error?.message || response.statusText}</div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå Connection error: ${error.message}</div>`;
      }
    }

    // HTML escape
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========== Event Listeners ==========
    
    document.getElementById("test-api-btn").addEventListener("click", testAPIKey);
    
    document.getElementById("start-btn").addEventListener("click", () => {
      state.config = {
        openAIKey: document.getElementById("api-key").value.trim(),
        modelChoice: document.getElementById("model-select").value,
        totalIterations: parseInt(document.getElementById("iterations").value),
        articlesPerIteration: parseInt(document.getElementById("articles-per-iter").value),
        topArticlesPerIteration: parseInt(document.getElementById("top-articles").value),
        searchStrategy: document.getElementById("search-strategy").value
      };
      
      const query = document.getElementById("query-input").value.trim();
      
      if (!state.config.openAIKey) {
        alert("Please enter your OpenAI API key.");
        return;
      }
      
      if (!query) {
        alert("Please enter a research query.");
        return;
      }
      
      runIterativeSearch(query);
    });
    
    document.getElementById("cancel-btn").addEventListener("click", () => {
      if (state.abortController) {
        state.abortController.abort();
      }
    });
    
    document.getElementById("summary-btn").addEventListener("click", generateAbstractSummary);
    
    // Initialize
    window.addEventListener('load', () => {
      document.getElementById("query-input").focus();
      
      if (window.location.protocol === 'file:') {
        document.getElementById('cors-warning').style.display = 'block';
      }
      
      loadPrompts();
    });
  </script>
</body>
</html>
