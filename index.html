<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI-Powered PubMed Research Tool - MeSH Enhanced Edition</title>
  <style>
    /* Professional styling with clear visual hierarchy */
    * {
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      color: #1a5490;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.2em;
    }
    
    h2, h3 { 
      color: #2E5AAC;
      margin-top: 20px;
    }
    
    /* Form elements */
    label { 
      font-weight: 600;
      display: inline-block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #495057;
    }
    
    input, select, button, textarea { 
      margin: 5px 0;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4dabf7;
      box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.1);
    }
    
    button {
      cursor: pointer;
      background-color: #228be6;
      color: white;
      border: none;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    button:hover:not(:disabled) {
      background-color: #1971c2;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    button:disabled { 
      background-color: #e9ecef;
      color: #868e96;
      cursor: not-allowed;
    }
    
    /* Section styling */
    .section { 
      background: white;
      border: 1px solid #dee2e6;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Tab system */
    .tabs {
      display: flex;
      border-bottom: 2px solid #dee2e6;
      margin-bottom: 20px;
      background: white;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }
    
    .tab {
      padding: 12px 24px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-weight: 600;
      color: #495057;
      transition: all 0.3s ease;
      flex: 1;
      text-align: center;
    }
    
    .tab:hover {
      background: #e9ecef;
    }
    
    .tab.active {
      background: white;
      color: #228be6;
      border-bottom: 3px solid #228be6;
      margin-bottom: -2px;
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Status indicators */
    #progress-status { 
      font-style: italic;
      color: #495057;
      margin-top: 10px;
      padding: 10px;
      background: #e7f5ff;
      border-radius: 5px;
      display: inline-block;
    }
    
    /* Output areas */
    .output-area {
      width: 100%;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      background: #f8f9fa;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      line-height: 1.5;
    }
    
    #iteration-log {
      max-height: 500px;
    }
    
    /* MeSH term validation */
    .mesh-valid {
      background-color: #d3f9d8;
      color: #2b8a3e;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    .mesh-invalid {
      background-color: #ffe0e0;
      color: #c92a2a;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    .mesh-discovered {
      background-color: #e3f2fd;
      color: #1976d2;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    /* Search term display */
    .search-term {
      background: #f1f3f5;
      padding: 8px;
      margin: 5px 0;
      border-left: 4px solid #339af0;
      font-family: monospace;
      font-size: 12px;
    }
    
    .search-term-failed {
      border-left-color: #c92a2a;
      background: #ffe0e0;
    }
    
    .search-term-success {
      border-left-color: #2b8a3e;
      background: #d3f9d8;
    }
    
    /* Relevance scores */
    .score-excellent {
      color: #2b8a3e;
      font-weight: bold;
    }
    
    .score-good {
      color: #5c940d;
      font-weight: bold;
    }
    
    .score-medium {
      color: #e67700;
      font-weight: bold;
    }
    
    .score-poor {
      color: #c92a2a;
      font-weight: bold;
    }
    
    /* API test result */
    .api-test-result {
      margin: 10px 0;
      padding: 12px;
      border-radius: 5px;
      font-weight: 500;
    }
    
    .api-test-success {
      background-color: #d3f9d8;
      color: #2b8a3e;
      border: 1px solid #8ce99a;
    }
    
    .api-test-failure {
      background-color: #ffe0e0;
      color: #c92a2a;
      border: 1px solid #ffa8a8;
    }
    
    /* Token display */
    .token-display {
      background: #e7f5ff;
      padding: 8px 15px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      display: inline-block;
      border: 1px solid #74c0fc;
      margin-left: 20px;
    }
    
    /* Results styling */
    .article-result {
      background: #f8f9fa;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .article-result h4 {
      margin: 0 0 10px 0;
      color: #1a5490;
    }
    
    .article-metadata {
      font-size: 13px;
      color: #6c757d;
      margin: 5px 0;
    }
    
    .article-abstract {
      margin-top: 10px;
      font-style: italic;
      color: #495057;
      line-height: 1.6;
    }
    
    /* Concept analysis display */
    .concept-box {
      background: #f1f3f5;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
    }
    
    .concept-box h5 {
      margin: 0 0 8px 0;
      color: #495057;
    }
    
    .synonym-list {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    
    .synonym-tag {
      background: white;
      border: 1px solid #339af0;
      color: #339af0;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 12px;
    }
    
    /* MeSH learning display */
    .mesh-learning-box {
      background: #e3f2fd;
      border: 1px solid #64b5f6;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
    }
    
    .mesh-learning-box h5 {
      margin: 0 0 8px 0;
      color: #1565c0;
    }
    
    /* Strategy info */
    .strategy-info {
      background: #e9ecef;
      border-radius: 5px;
      padding: 8px 12px;
      margin: 5px 0;
      font-size: 13px;
    }
    
    /* Buttons */
    .primary-button {
      background-color: #228be6;
      font-size: 16px;
      padding: 12px 24px;
      margin: 10px 0;
    }
    
    .secondary-button {
      background-color: #495057;
      font-size: 14px;
      padding: 8px 16px;
    }
    
    .success-button {
      background-color: #2b8a3e;
    }
    
    .warning-button {
      background-color: #e67700;
    }
    
    .danger-button {
      background-color: #c92a2a;
    }
    
    /* Info boxes */
    .info-box {
      background: #e7f5ff;
      border: 1px solid #74c0fc;
      border-radius: 5px;
      padding: 12px;
      margin: 10px 0;
    }
    
    .warning-box {
      background: #fff3cd;
      border: 1px solid #ffec99;
      border-radius: 5px;
      padding: 12px;
      margin: 10px 0;
      color: #856404;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üî¨ AI-Powered PubMed Research Tool - MeSH Enhanced Edition</h1>
    
    <!-- Tab Navigation -->
    <div class="tabs">
      <button class="tab active" onclick="showTab('search')">üîç Search</button>
      <button class="tab" onclick="showTab('results')">üìä Results</button>
      <button class="tab" onclick="showTab('evolution')">üß¨ Evolution</button>
      <button class="tab" onclick="showTab('config')">‚öôÔ∏è Settings</button>
    </div>
    
    <!-- Search Tab -->
    <div id="search-tab" class="tab-content active">
      <!-- Configuration Section -->
      <div class="section" id="config-section">
        <h2>Quick Configuration</h2>
        
        <!-- API Key Input -->
        <label for="api-key">OpenAI API Key:</label><br>
        <input type="password" id="api-key" placeholder="Enter your OpenAI API key (sk-...)" size="50" />
        <button id="test-api-btn" class="secondary-button" style="margin-left: 10px;">Test API Key</button>
        <div id="api-test-result"></div>
        
        <!-- Model Selection -->
        <label for="model-select">AI Model:</label>
        <select id="model-select" style="margin-left: 10px;">
          <option value="gpt-4-turbo" selected>GPT-4 Turbo</option>
          <option value="gpt-4o">GPT-4o</option>
          <option value="gpt-4o-mini">GPT-4o Mini (Cheaper)</option>
          <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Cheapest)</option>
        </select>
        
        <!-- Token Display -->
        <div class="token-display" id="token-display">
          üî§ Tokens - In: 0 | Out: 0 | Cost: $0.00
        </div>
      </div>

      <!-- Query Section -->
      <div class="section" id="query-section">
        <h2>Research Query</h2>
        <label for="query-input">Enter your medical research question:</label><br>
        <input type="text" id="query-input" size="80" 
               placeholder="e.g. 'effects of metformin on diabetes prevention in prediabetic patients'" 
               style="width: 100%; font-size: 16px; padding: 10px;" />
        
        <h3>Search Parameters</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <div>
            <label for="iterations">Iterations:</label>
            <input type="number" id="iterations" value="4" min="2" max="8" style="width:60px;" />
          </div>
          
          <div>
            <label for="articles-per-iter">Articles per iteration:</label>
            <input type="number" id="articles-per-iter" value="25" min="10" max="50" style="width:60px;" />
          </div>
          
          <div>
            <label for="top-articles">Top articles to analyze:</label>
            <input type="number" id="top-articles" value="8" min="3" max="15" style="width:60px;" />
          </div>
          
          <div>
            <label for="search-strategy">Search Strategy:</label>
            <select id="search-strategy">
              <option value="broad-then-narrow" selected>Broad ‚Üí Narrow (MeSH Learning)</option>
              <option value="focused">Focused Only</option>
              <option value="exploratory">Exploratory</option>
            </select>
          </div>
        </div>
        
        <button id="start-btn" class="primary-button" style="margin-top: 20px;">
          üîç Start Iterative Search
        </button>
        <button id="cancel-btn" class="primary-button danger-button" style="display:none;">
          ‚ùå Cancel Search
        </button>
        <span id="progress-status"></span>
      </div>

      <!-- Progress Log Section -->
      <div class="section" id="log-section">
        <h2>Search Progress</h2>
        <div id="iteration-log" class="output-area" aria-live="polite"></div>
      </div>
      
      <!-- MeSH Learning Display -->
      <div class="section" id="mesh-learning-section" style="display:none;">
        <h2>üè∑Ô∏è Discovered MeSH Terms</h2>
        <div id="mesh-terms-display"></div>
      </div>
    </div>
    
    <!-- Results Tab -->
    <div id="results-tab" class="tab-content">
      <div class="section" id="results-section">
        <h2>Top Articles with Abstracts</h2>
        <div id="results" class="output-area"></div>
        
        <h3>AI Summary of Top Articles</h3>
        <div style="margin: 10px 0;">
          <label for="summary-count">Summarize top</label>
          <input type="number" id="summary-count" value="5" min="3" max="15" style="width:50px;" /> articles
          <button id="summary-btn" class="secondary-button" style="margin-left: 10px;">Generate Summary</button>
        </div>
        <div id="summary" class="output-area"></div>
      </div>
    </div>
    
    <!-- Evolution Tab -->
    <div id="evolution-tab" class="tab-content">
      <div class="section" id="evolution-section">
        <h2>Search Evolution Overview</h2>
        <div id="evolution" class="output-area"></div>
        
        <h3>Complete Article Rankings</h3>
        <div id="rankings" class="output-area"></div>
      </div>
    </div>
    
    <!-- Configuration Tab -->
    <div id="config-tab" class="tab-content">
      <div class="section">
        <h2>Advanced Settings</h2>
        
        <h3>Search Behavior</h3>
        <label>
          <input type="checkbox" id="use-broad-search" checked> 
          Start with broad two-concept searches
        </label><br>
        
        <label>
          <input type="checkbox" id="learn-mesh" checked> 
          Learn and use MeSH terms from successful results
        </label><br>
        
        <label>
          <input type="checkbox" id="validate-mesh" checked> 
          Validate MeSH terms before searching
        </label><br>
        
        <label>
          <input type="checkbox" id="show-mesh-feedback" checked> 
          Show MeSH validation feedback
        </label><br>
        
        <h3>Result Processing</h3>
        <label for="min-relevance">Minimum relevance score to display:</label>
        <input type="number" id="min-relevance" value="20" min="0" max="100" style="width:60px;" /><br>
        
        <label for="mesh-learning-threshold">Min score for MeSH learning:</label>
        <input type="number" id="mesh-learning-threshold" value="70" min="50" max="100" style="width:60px;" /><br>
        
        <label for="rate-limit">API rate limit delay (ms):</label>
        <input type="number" id="rate-limit" value="400" min="100" max="2000" style="width:80px;" /><br>
        
        <h3>Export Options</h3>
        <button onclick="exportResults('json')" class="secondary-button">Export as JSON</button>
        <button onclick="exportResults('csv')" class="secondary-button">Export as CSV</button>
        <button onclick="exportResults('txt')" class="secondary-button">Export as Text</button>
      </div>
    </div>
  </div>

  <script>
    // ========== Global State Management ==========
    let state = {
      config: {},
      searchState: {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        meshTermsValidated: {},
        searchHistory: [],
        successfulTerms: new Set(),
        failedSearches: [],
        conceptAnalysis: null,
        searchPatterns: {
          successful: [],
          failed: []
        },
        discoveredMeshTerms: new Set(),
        meshTermFrequency: {},
        relatedFindings: [],
        missingConcepts: []
      },
      abortController: null,
      currentTab: 'search'
    };

    // ========== Token Counter ==========
    class TokenCounter {
      constructor() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
      
      estimateTokens(text) {
        return Math.ceil(text.length / 4);
      }
      
      addApiCall(prompt, response) {
        this.inputTokens += this.estimateTokens(prompt);
        this.outputTokens += this.estimateTokens(response);
        updateTokenDisplay();
      }
      
      getCostEstimate(model = "gpt-4-turbo") {
        const pricing = {
          "gpt-4-turbo": { input: 0.01, output: 0.03 },
          "gpt-4o": { input: 0.005, output: 0.015 },
          "gpt-4o-mini": { input: 0.00015, output: 0.0006 },
          "gpt-3.5-turbo": { input: 0.0005, output: 0.0015 }
        };
        
        const modelPricing = pricing[model] || pricing["gpt-4-turbo"];
        const inputCost = (this.inputTokens / 1000) * modelPricing.input;
        const outputCost = (this.outputTokens / 1000) * modelPricing.output;
        
        return inputCost + outputCost;
      }
      
      reset() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
    }

    const tokenCounter = new TokenCounter();

    // ========== Helper Functions ==========
    
    // Tab management
    function showTab(tabName) {
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.getElementById(`${tabName}-tab`).classList.add('active');
      event.target.classList.add('active');
      state.currentTab = tabName;
    }

    // Enhanced logging with HTML support
    function logMessage(message, isHtml = false) {
      const logArea = document.getElementById("iteration-log");
      const timestamp = new Date().toLocaleTimeString();
      
      if (isHtml) {
        const div = document.createElement('div');
        div.innerHTML = `[${timestamp}] ${message}`;
        logArea.appendChild(div);
      } else {
        logArea.textContent += `[${timestamp}] ${message}`;
      }
      logArea.scrollTop = logArea.scrollHeight;
    }

    // Update token display
    function updateTokenDisplay() {
      const cost = tokenCounter.getCostEstimate(state.config.modelChoice);
      document.getElementById("token-display").textContent = 
        `üî§ Tokens - In: ${tokenCounter.inputTokens.toLocaleString()} | Out: ${tokenCounter.outputTokens.toLocaleString()} | Cost: $${cost.toFixed(4)}`;
    }

    // ========== API Functions ==========
    
    // OpenAI API call
    async function callOpenAI(prompt, temperature = 0.3, maxTokens = 1000) {
      const requestBody = {
        model: state.config.modelChoice,
        messages: [{ role: "user", content: prompt }],
        temperature: temperature,
        max_tokens: maxTokens
      };
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${state.config.openAIKey}`
          },
          body: JSON.stringify(requestBody),
          signal: state.abortController?.signal
        });
        
        const responseText = await response.text();
        
        if (!response.ok) {
          let errorMessage = `OpenAI API Error: ${response.status}`;
          try {
            const errorData = JSON.parse(responseText);
            if (errorData.error?.message) {
              errorMessage = errorData.error.message;
            }
          } catch (e) {}
          throw new Error(errorMessage);
        }
        
        const data = JSON.parse(responseText);
        const text = data.choices[0].message.content.trim();
        
        tokenCounter.addApiCall(prompt, text);
        
        return text;
      } catch (error) {
        if (error.name === 'AbortError') {
          logMessage("‚ùå API call cancelled.\n");
        } else {
          logMessage(`‚ùå API Error: ${error.message}\n`);
        }
        throw error;
      }
    }

    // Analyze query concepts
    async function analyzeQueryConcepts(query) {
      logMessage("\nüß† Analyzing query concepts and synonyms...\n");
      
      const prompt = `Analyze this medical research query: "${query}"

Break it down into core concepts and provide synonyms:

1. PRIMARY SUBJECT: Main gene/protein/drug/therapy
2. CONDITION/PHENOTYPE: Disease, biological process, or phenotype
3. TISSUE/CELL TYPE: Anatomical location or cell type
4. MODEL/METHOD: Experimental model or methodology

For each concept, provide:
- Primary term
- 2-3 synonyms or related terms
- MeSH term if known

Format each term in [[brackets]].

Example:
PRIMARY: [[metformin]], [[biguanide]], [[glucophage]]
CONDITION: [[diabetes]], [[type 2 diabetes]], [[T2DM]]`;

      try {
        const response = await callOpenAI(prompt, 0.3, 600);
        
        // Parse concepts
        const concepts = {
          primary: [],
          condition: [],
          tissue: [],
          method: []
        };
        
        const lines = response.split('\n');
        lines.forEach(line => {
          const terms = line.match(/\[\[([^\]]+)\]\]/g);
          if (terms) {
            const cleanTerms = terms.map(t => t.replace(/\[\[|\]\]/g, ''));
            if (line.includes('PRIMARY')) concepts.primary.push(...cleanTerms);
            else if (line.includes('CONDITION') || line.includes('PHENOTYPE')) concepts.condition.push(...cleanTerms);
            else if (line.includes('TISSUE') || line.includes('CELL')) concepts.tissue.push(...cleanTerms);
            else if (line.includes('MODEL') || line.includes('METHOD')) concepts.method.push(...cleanTerms);
          }
        });
        
        // Display concepts
        logMessage('<div class="concept-box">', true);
        Object.entries(concepts).forEach(([category, terms]) => {
          if (terms.length > 0) {
            logMessage(`<h5>${category.toUpperCase()}:</h5><div class="synonym-list">`, true);
            terms.forEach(term => {
              logMessage(`<span class="synonym-tag">${term}</span>`, true);
            });
            logMessage('</div>', true);
          }
        });
        logMessage('</div>\n', true);
        
        state.searchState.conceptAnalysis = concepts;
        return concepts;
        
      } catch (e) {
        logMessage(`‚ö†Ô∏è Concept analysis failed: ${e.message}\n`);
        // Fallback
        const terms = query.match(/\b\w+\b/g) || [];
        return {
          primary: terms.slice(0, 2),
          condition: terms.slice(2, 4),
          tissue: [],
          method: []
        };
      }
    }

    // Generate broad two-concept searches
    function generateBroadTwoConceptSearches(concepts) {
      const searches = [];
      
      // Helper to create OR groups
      const makeOrGroup = (terms) => {
        if (!terms || terms.length === 0) return null;
        if (terms.length === 1) return terms[0];
        return `(${terms.slice(0, 3).map(t => `"${t}"`).join(' OR ')})`;
      };
      
      // Two-concept combinations
      const combinations = [
        [concepts.primary, concepts.condition],
        [concepts.primary, concepts.tissue],
        [concepts.primary, concepts.method],
        [concepts.condition, concepts.tissue],
        [concepts.condition, concepts.method]
      ];
      
      combinations.forEach(([terms1, terms2]) => {
        if (terms1?.length > 0 && terms2?.length > 0) {
          searches.push(`${makeOrGroup(terms1)} AND ${makeOrGroup(terms2)}`);
        }
      });
      
      // Also add single concept searches for very broad coverage
      if (searches.length < 3) {
        if (concepts.primary?.length > 0) searches.push(makeOrGroup(concepts.primary));
        if (concepts.condition?.length > 0) searches.push(makeOrGroup(concepts.condition));
      }
      
      return searches.filter(s => s !== null).slice(0, 5);
    }

    // Generate MeSH-based searches from discovered terms
    function generateMeshBasedSearches(meshTerms, concepts) {
      const searches = [];
      
      // Sort MeSH terms by frequency
      const sortedMesh = Object.entries(meshTerms)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15)
        .map(([term]) => term);
      
      if (sortedMesh.length >= 2) {
        // Pairwise combinations of top MeSH terms
        for (let i = 0; i < Math.min(sortedMesh.length - 1, 3); i++) {
          for (let j = i + 1; j < Math.min(sortedMesh.length, 4); j++) {
            searches.push(`"${sortedMesh[i]}"[MeSH] AND "${sortedMesh[j]}"[MeSH]`);
            if (searches.length >= 3) break;
          }
        }
      }
      
      // Combine MeSH terms with original concepts
      if (sortedMesh.length > 0 && concepts.primary?.length > 0) {
        searches.push(`"${sortedMesh[0]}"[MeSH] AND "${concepts.primary[0]}"`);
      }
      
      return searches;
    }

    // Generate refined search terms
    async function generateRefinedSearchTerms(query, iteration, concepts) {
      logMessage("\nüîç Generating refined search strategies...\n");
      
      const context = buildSearchContext();
      const meshTerms = Array.from(state.searchState.discoveredMeshTerms).slice(0, 10).join(", ");
      
      const prompt = `Generate refined PubMed searches for: "${query}"

Context from previous searches:
${context}

Discovered MeSH terms: ${meshTerms || "none yet"}

Create 5 search strategies that:
1. Use discovered MeSH terms if available
2. Try different concept combinations
3. Avoid failed search patterns
4. Build on successful patterns

Use proper PubMed syntax with [MeSH] tags, AND/OR operators.
Return only the search strings, one per line.`;

      try {
        const response = await callOpenAI(prompt, 0.4, 600);
        
        // Extract search terms
        const searches = response.split('\n')
          .filter(line => line.trim().length > 10)
          .map(line => line.replace(/^\d+\.\s*/, '').trim())
          .filter(s => s.includes(' ') || s.includes('['))
          .slice(0, 5);
        
        return searches.length > 0 ? searches : generateBroadTwoConceptSearches(concepts);
      } catch (e) {
        logMessage(`‚ö†Ô∏è Failed to generate refined searches: ${e.message}\n`);
        return generateBroadTwoConceptSearches(concepts);
      }
    }

    // Build search context
    function buildSearchContext() {
      let context = "Search progress:\n";
      
      state.searchState.iterationsData.slice(-2).forEach(iter => {
        context += `\nIteration ${iter.number}:\n`;
        context += `- Articles found: ${iter.articlesFound}\n`;
        context += `- Best score: ${iter.bestScore || 0}\n`;
        
        if (iter.topArticles && iter.topArticles.length > 0) {
          context += `- Top article: "${iter.topArticles[0].title}" (score: ${iter.topArticles[0].relevance_score})\n`;
        }
      });
      
      // Add successful patterns
      const successfulPatterns = state.searchState.searchPatterns.successful.slice(-3);
      if (successfulPatterns.length > 0) {
        context += "\nSuccessful searches:\n";
        successfulPatterns.forEach(p => {
          context += `- "${p.query}" (${p.results} results)\n`;
        });
      }
      
      return context;
    }

    // Validate MeSH term
    async function validateMeshTerm(term) {
      if (state.searchState.meshTermsValidated[term] !== undefined) {
        return state.searchState.meshTermsValidated[term];
      }
      
      const url = `https://id.nlm.nih.gov/mesh/lookup/descriptor?label=${encodeURIComponent(term)}&match=exact&limit=1`;
      
      try {
        const resp = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`, {
          signal: state.abortController?.signal
        });
        
        if (!resp.ok) return false;
        
        const data = await resp.json();
        const isValid = Array.isArray(data) && data.length > 0 && data[0].label === term;
        
        state.searchState.meshTermsValidated[term] = isValid;
        return isValid;
      } catch (error) {
        console.warn("MeSH verification error:", error);
        return false;
      }
    }

    // Search PubMed
    async function searchPubMed(query, maxResults = 20) {
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(query)}&retmode=xml&retmax=${maxResults}&tool=AI_PubMed_Tool&email=tool@example.com&sort=relevance`;
      
      try {
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const resp = await fetch(proxyUrl, { signal: state.abortController?.signal });
        
        if (!resp.ok) throw new Error(`PubMed error: ${resp.status}`);
        
        const xmlText = await resp.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "text/xml");
        
        const errorNode = xmlDoc.querySelector("ERROR");
        if (errorNode) {
          throw new Error(`PubMed API: ${errorNode.textContent}`);
        }
        
        const idElements = Array.from(xmlDoc.getElementsByTagName("Id"));
        return idElements.map(idNode => idNode.textContent);
      } catch (error) {
        if (error.name !== 'AbortError') {
          logMessage(`‚ùå PubMed search error: ${error.message}\n`);
        }
        return [];
      }
    }

    // Fetch article details
    async function fetchPubMedDetails(pmids) {
      if (pmids.length === 0) return [];
      
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${pmids.join(",")}&retmode=xml&tool=AI_PubMed_Tool&email=tool@example.com`;
      
      try {
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const resp = await fetch(proxyUrl, { signal: state.abortController?.signal });
        
        if (!resp.ok) throw new Error(`PubMed fetch error: ${resp.status}`);
        
        const xmlText = await resp.text();
        const xmlDoc = new DOMParser().parseFromString(xmlText, "text/xml");
        const articleNodes = Array.from(xmlDoc.getElementsByTagName("PubmedArticle"));
        
        return articleNodes.map(parseArticleXML);
      } catch (error) {
        if (error.name !== 'AbortError') {
          logMessage(`‚ùå Fetch error: ${error.message}\n`);
        }
        return [];
      }
    }

    // Parse article XML
    function parseArticleXML(articleNode) {
      function textOrDefault(elem, tag, defaultVal = "") {
        const node = elem.getElementsByTagName(tag)[0];
        return node && node.textContent ? node.textContent : defaultVal;
      }
      
      const pmid = textOrDefault(articleNode, "PMID", "Unknown");
      const title = textOrDefault(articleNode, "ArticleTitle", "No Title");
      
      const authors = Array.from(articleNode.getElementsByTagName("Author")).map(auth => {
        const lastName = textOrDefault(auth, "LastName");
        const foreName = textOrDefault(auth, "ForeName");
        return lastName ? (foreName ? `${lastName}, ${foreName}` : lastName) : null;
      }).filter(Boolean);
      
      const journal = textOrDefault(articleNode, "Title", "Unknown Journal");
      
      const pubDateNode = articleNode.getElementsByTagName("PubDate")[0];
      let pubYear = "Unknown";
      if (pubDateNode) {
        pubYear = textOrDefault(pubDateNode, "Year") || 
                  textOrDefault(pubDateNode, "MedlineDate", "Unknown").substring(0, 4);
      }
      
      const abstractTexts = Array.from(articleNode.getElementsByTagName("AbstractText"))
        .map(node => {
          const label = node.getAttribute("Label");
          return label ? `${label}: ${node.textContent}` : node.textContent;
        })
        .join(" ");
      
      // Extract MeSH terms - crucial for learning
      const meshTerms = Array.from(articleNode.getElementsByTagName("MeshHeading"))
        .map(heading => {
          const descriptor = heading.getElementsByTagName("DescriptorName")[0];
          return descriptor ? descriptor.textContent : null;
        })
        .filter(Boolean);
      
      return {
        pmid,
        title,
        authors,
        journal,
        pub_date: pubYear,
        abstract: abstractTexts.trim(),
        meshTerms,
        relevance_score: 0,
        ai_reasoning: "",
        found_in_iteration: 0,
        concepts_present: []
      };
    }

    // Analyze articles with AI
    async function analyzeArticles(query, articles, concepts) {
      if (articles.length === 0) return [];
      
      logMessage("ü§ñ Analyzing articles for relevance...\n");
      
      const articleInfo = articles.map((a, i) => ({
        index: i + 1,
        title: a.title,
        abstract: a.abstract ? a.abstract.substring(0, 500) + "..." : "No abstract",
        journal: a.journal,
        year: a.pub_date,
        meshTerms: a.meshTerms.slice(0, 5).join(', ')
      }));
      
      const conceptsStr = Object.entries(concepts)
        .map(([key, terms]) => `${key}: ${terms.join(', ')}`)
        .join('\n');
      
      const prompt = `Analyze these articles for relevance to: "${query}"

Target concepts:
${conceptsStr}

For each article, provide:
- Relevance score (0-100)
- Brief reasoning
- Which concepts are present

Articles:
${JSON.stringify(articleInfo, null, 2)}

Return JSON: [{"index": 1, "score": 85, "reasoning": "...", "concepts": ["primary", "condition"]}, ...]`;

      try {
        const response = await callOpenAI(prompt, 0.2, 1500);
        const analysis = JSON.parse(response);
        
        analysis.forEach(result => {
          const idx = result.index - 1;
          if (articles[idx]) {
            articles[idx].relevance_score = result.score;
            articles[idx].ai_reasoning = result.reasoning;
            articles[idx].concepts_present = result.concepts || [];
          }
        });
        
      } catch (e) {
        logMessage(`‚ö†Ô∏è Analysis failed: ${e.message}. Using fallback scoring.\n`);
        articles.forEach(a => {
          a.relevance_score = 50;
          a.ai_reasoning = "AI analysis unavailable";
        });
      }
      
      return articles;
    }

    // Learn MeSH terms from high-scoring articles
    function learnMeshTermsFromArticles(articles) {
      const meshThreshold = parseInt(document.getElementById('mesh-learning-threshold').value);
      
      articles.forEach(article => {
        if (article.relevance_score >= meshThreshold && article.meshTerms) {
          article.meshTerms.forEach(term => {
            state.searchState.discoveredMeshTerms.add(term);
            state.searchState.meshTermFrequency[term] = 
              (state.searchState.meshTermFrequency[term] || 0) + 1;
          });
        }
      });
      
      if (state.searchState.discoveredMeshTerms.size > 0) {
        displayDiscoveredMeshTerms();
      }
    }

    // Display discovered MeSH terms
    function displayDiscoveredMeshTerms() {
      const meshSection = document.getElementById('mesh-learning-section');
      const meshDisplay = document.getElementById('mesh-terms-display');
      
      meshSection.style.display = 'block';
      
      logMessage('\n<div class="mesh-learning-box">', true);
      logMessage('<h5>üè∑Ô∏è Discovered MeSH Terms from High-Scoring Articles:</h5>', true);
      logMessage('<div class="synonym-list">', true);
      
      // Show top MeSH terms by frequency
      const sortedMesh = Object.entries(state.searchState.meshTermFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
      
      meshDisplay.innerHTML = '';
      sortedMesh.forEach(([term, count]) => {
        const span = document.createElement('span');
        span.className = 'synonym-tag mesh-discovered';
        span.innerHTML = `${term} <strong>(${count})</strong>`;
        meshDisplay.appendChild(span);
        meshDisplay.appendChild(document.createTextNode(' '));
        
        logMessage(`<span class="synonym-tag mesh-discovered">${term} (${count})</span>`, true);
      });
      
      logMessage('</div></div>\n', true);
    }

    // Generate iteration insights
    async function generateIterationInsights(query, iteration, topArticles) {
      if (topArticles.length === 0) return;
      
      const prompt = `Analyze iteration ${iteration} results for: "${query}"

Top articles found:
${topArticles.slice(0, 3).map((a, i) => 
  `${i + 1}. ${a.title} (Score: ${a.relevance_score})`
).join('\n')}

Provide brief insights:
1. What's working well?
2. What concepts are missing?
3. Suggested next steps?

Keep it concise (2-3 sentences each).`;

      try {
        const insights = await callOpenAI(prompt, 0.3, 400);
        logMessage(`\nüí° Iteration Insights:\n${insights}\n`);
      } catch (e) {
        logMessage(`‚ö†Ô∏è Could not generate insights: ${e.message}\n`);
      }
    }

    // Display search terms with validation
    async function displaySearchTerms(searchTerms, iteration, strategy) {
      logMessage(`\nüìã Search strategies for iteration ${iteration} (${strategy}):\n`);
      
      for (let i = 0; i < searchTerms.length; i++) {
        const term = searchTerms[i];
        
        // Check for MeSH terms and validate if enabled
        let displayTerm = term;
        if (document.getElementById('validate-mesh').checked) {
          const meshMatches = [...term.matchAll(/"([^"]+)"\[MeSH\]/g)];
          
          for (const match of meshMatches) {
            const meshTerm = match[1];
            const isValid = await validateMeshTerm(meshTerm);
            
            if (document.getElementById('show-mesh-feedback').checked) {
              const status = isValid ? 
                '<span class="mesh-valid">‚úì</span>' : 
                '<span class="mesh-invalid">‚úó</span>';
              displayTerm = displayTerm.replace(match[0], match[0] + ' ' + status);
            }
          }
        }
        
        logMessage(`<div class="search-term">${i + 1}. ${displayTerm}</div>`, true);
      }
      
      logMessage("\n");
    }

    // Main search function
    async function runIterativeSearch(query) {
      toggleUI(true);
      resetSearchState();
      state.abortController = new AbortController();
      
      clearAllDisplays();
      
      logMessage(`üöÄ Starting iterative search for: "${query}"\n`);
      logMessage("=" + "=".repeat(60) + "\n\n");
      
      try {
        // Step 1: Analyze query concepts
        const concepts = await analyzeQueryConcepts(query);
        
        const maxIterations = state.config.totalIterations;
        const articlesPerIter = state.config.articlesPerIteration;
        
        for (let iter = 1; iter <= maxIterations; iter++) {
          if (state.abortController.signal.aborted) {
            throw new Error("Search cancelled");
          }
          
          logMessage(`\n${"=".repeat(60)}\n`);
          logMessage(`üîÑ ITERATION ${iter} of ${maxIterations}\n`);
          logMessage(`${"=".repeat(60)}\n`);
          
          let searchTerms = [];
          let strategy = "";
          
          // Determine search strategy
          if (iter === 1 && document.getElementById('use-broad-search').checked) {
            // First iteration: broad two-concept searches
            strategy = "Broad Two-Concept Search";
            searchTerms = generateBroadTwoConceptSearches(concepts);
          } else if (iter > 1 && state.searchState.discoveredMeshTerms.size >= 4 && 
                     document.getElementById('learn-mesh').checked) {
            // Use discovered MeSH terms
            strategy = "MeSH-Based Search";
            searchTerms = generateMeshBasedSearches(state.searchState.meshTermFrequency, concepts);
            
            // Add some refined searches
            const refinedSearches = await generateRefinedSearchTerms(query, iter, concepts);
            searchTerms.push(...refinedSearches.slice(0, 2));
          } else {
            // Refined search based on learning
            strategy = "Refined Search";
            searchTerms = await generateRefinedSearchTerms(query, iter, concepts);
          }
          
          // Display search terms
          await displaySearchTerms(searchTerms, iter, strategy);
          
          // Execute searches
          logMessage("\nüîç Executing searches...\n");
          const allPmids = [];
          const articlesPerSearch = Math.ceil(articlesPerIter / searchTerms.length);
          
          for (let i = 0; i < searchTerms.length; i++) {
            const term = searchTerms[i];
            logMessage(`  Search ${i + 1}: `);
            
            try {
              const pmids = await searchPubMed(term, articlesPerSearch + 5);
              allPmids.push(...pmids);
              
              if (pmids.length > 0) {
                logMessage(`<span class="search-term-success">‚úÖ Found ${pmids.length} articles</span>\n`, true);
                state.searchState.successfulTerms.add(term);
                state.searchState.searchPatterns.successful.push({
                  query: term,
                  results: pmids.length,
                  iteration: iter
                });
              } else {
                logMessage(`<span class="search-term-failed">‚ùå No results</span>\n`, true);
                state.searchState.failedSearches.push(term);
              }
            } catch (searchError) {
              logMessage(`‚ùå Error: ${searchError.message}\n`);
              state.searchState.failedSearches.push(term);
            }
            
            // Rate limiting
            await new Promise(resolve => 
              setTimeout(resolve, parseInt(document.getElementById('rate-limit').value))
            );
          }
          
          // Process unique PMIDs
          const uniquePmids = [...new Set(allPmids)];
          logMessage(`\nüìä Total unique articles found: ${uniquePmids.length}\n`);
          
          if (uniquePmids.length === 0) {
            logMessage("‚ö†Ô∏è No articles found this iteration.\n");
            continue;
          }
          
          // Fetch new articles
          const newPmids = uniquePmids.filter(pmid => !state.searchState.allArticles[pmid]);
          if (newPmids.length > 0) {
            logMessage(`üì• Fetching details for ${newPmids.length} new articles...\n`);
            try {
              const newArticles = await fetchPubMedDetails(newPmids);
              
              newArticles.forEach(article => {
                article.found_in_iteration = iter;
                state.searchState.allArticles[article.pmid] = article;
              });
            } catch (fetchError) {
              logMessage(`‚ùå Error fetching article details: ${fetchError.message}\n`);
            }
          }
          
          // Get current iteration's articles
          const currentArticles = uniquePmids
            .map(pmid => state.searchState.allArticles[pmid])
            .filter(Boolean);
          
          // Analyze articles
          const analyzedArticles = await analyzeArticles(query, currentArticles, concepts);
          
          // Sort by relevance
          analyzedArticles.sort((a, b) => b.relevance_score - a.relevance_score);
          
          // Learn MeSH terms from high-scoring articles
          if (document.getElementById('learn-mesh').checked) {
            learnMeshTermsFromArticles(analyzedArticles);
          }
          
          // Display top articles
          const topArticles = analyzedArticles.slice(0, state.config.topArticlesPerIteration);
          displayIterationResults(iter, topArticles);
          
          // Generate iteration insights
          await generateIterationInsights(query, iter, topArticles);
          
          // Store iteration data
          state.searchState.iterationsData.push({
            number: iter,
            searchTerms,
            articlesFound: uniquePmids.length,
            newArticles: newPmids.length,
            bestScore: topArticles[0]?.relevance_score || 0,
            topArticles,
            strategy
          });
        }
        
        // Finalize results
        await finalizeResults(query);
        
      } catch (error) {
        handleSearchError(error);
      } finally {
        toggleUI(false);
      }
    }

    // Display iteration results
    function displayIterationResults(iteration, topArticles) {
      logMessage(`\nüèÜ Top articles for iteration ${iteration}:\n`);
      
      const minScore = parseInt(document.getElementById('min-relevance').value);
      
      topArticles.slice(0, 5).forEach((article, i) => {
        if (article.relevance_score >= minScore) {
          const scoreClass = article.relevance_score >= 80 ? 'score-excellent' :
                           article.relevance_score >= 60 ? 'score-good' :
                           article.relevance_score >= 40 ? 'score-medium' : 'score-poor';
          
          logMessage(`\n${i + 1}. ${article.title}\n`);
          logMessage(`   <span class="${scoreClass}">Score: ${article.relevance_score}/100</span>\n`, true);
          logMessage(`   ${article.ai_reasoning}\n`);
          
          if (article.meshTerms && article.meshTerms.length > 0) {
            logMessage(`   MeSH terms: ${article.meshTerms.slice(0, 5).join(', ')}\n`);
          }
        }
      });
    }

    // Finalize results
    async function finalizeResults(query) {
      const allArticles = Object.values(state.searchState.allArticles);
      
      if (allArticles.length === 0) {
        logMessage("\n‚ö†Ô∏è No articles found in the entire search.\n");
        return;
      }
      
      logMessage(`\n\n${"=".repeat(60)}\n`);
      logMessage(`üéØ FINALIZING RESULTS\n`);
      logMessage(`${"=".repeat(60)}\n`);
      
      // Final ranking based on scores
      state.searchState.finalRanking = allArticles
        .sort((a, b) => b.relevance_score - a.relevance_score);
      
      // Display results
      displayFinalResults();
      generateSearchSummary(query);
      
      logMessage("\n‚úÖ Search completed successfully!\n");
    }

    // Display final results
    function displayFinalResults() {
      const resultsDiv = document.getElementById("results");
      const topArticles = state.searchState.finalRanking.slice(0, 10);
      
      let html = '<h3>Top Articles</h3>\n';
      
      topArticles.forEach((article, i) => {
        const scoreClass = article.relevance_score >= 80 ? 'score-excellent' :
                         article.relevance_score >= 60 ? 'score-good' :
                         article.relevance_score >= 40 ? 'score-medium' : 'score-poor';
        
        html += `<div class="article-result">`;
        html += `<h4>#${i + 1}: ${escapeHtml(article.title)}</h4>`;
        html += `<div class="article-metadata">`;
        html += `<strong>Authors:</strong> ${article.authors.slice(0, 3).join(", ")}`;
        if (article.authors.length > 3) html += ` + ${article.authors.length - 3} more`;
        html += `<br><strong>Journal:</strong> ${escapeHtml(article.journal)} (${article.pub_date})`;
        html += `<br><strong>PMID:</strong> ${article.pmid}`;
        html += ` | <strong class="${scoreClass}">Score: ${article.relevance_score}/100</strong>`;
        html += ` | <strong>Found in iteration:</strong> ${article.found_in_iteration}`;
        html += `<br><strong>URL:</strong> <a href="https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/" target="_blank">View on PubMed</a>`;
        html += `<br><strong>AI Assessment:</strong> ${escapeHtml(article.ai_reasoning)}`;
        
        if (article.meshTerms && article.meshTerms.length > 0) {
          html += `<br><strong>MeSH terms:</strong> ${article.meshTerms.slice(0, 8).join(', ')}`;
        }
        
        html += `</div>`;
        
        if (article.abstract) {
          html += `<div class="article-abstract">`;
          html += `<strong>Abstract:</strong><br>${escapeHtml(article.abstract)}`;
          html += `</div>`;
        }
        
        html += `</div>`;
      });
      
      resultsDiv.innerHTML = html;
      
      // Rankings
      const rankingsDiv = document.getElementById("rankings");
      let rankingsText = `COMPLETE ARTICLE RANKINGS\n${"=".repeat(50)}\n\n`;
      
      state.searchState.finalRanking.forEach((article, i) => {
        rankingsText += `${i + 1}. ${article.title}\n`;
        rankingsText += `   PMID: ${article.pmid} | Score: ${article.relevance_score} | Iteration: ${article.found_in_iteration}\n\n`;
      });
      
      rankingsDiv.textContent = rankingsText;
    }

    // Generate search summary
    async function generateSearchSummary(query) {
      const evolutionDiv = document.getElementById("evolution");
      
      let summaryText = `SEARCH EVOLUTION\n${"=".repeat(50)}\n\n`;
      summaryText += `Query: "${query}"\n`;
      summaryText += `Total iterations: ${state.searchState.iterationsData.length}\n`;
      summaryText += `Total unique articles: ${Object.keys(state.searchState.allArticles).length}\n`;
      summaryText += `Articles in final ranking: ${state.searchState.finalRanking.length}\n\n`;
      
      // MeSH terms discovered
      if (state.searchState.discoveredMeshTerms.size > 0) {
        summaryText += `\nDISCOVERED MeSH TERMS:\n`;
        const topMesh = Object.entries(state.searchState.meshTermFrequency)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10);
        
        topMesh.forEach(([term, count]) => {
          summaryText += `  ‚Ä¢ ${term} (${count} occurrences)\n`;
        });
      }
      
      // Iteration breakdown
      summaryText += `\nITERATION BREAKDOWN:\n`;
      state.searchState.iterationsData.forEach(iter => {
        summaryText += `\nIteration ${iter.number} (${iter.strategy}):\n`;
        summaryText += `  ‚Ä¢ Articles found: ${iter.articlesFound} (${iter.newArticles} new)\n`;
        summaryText += `  ‚Ä¢ Best score: ${iter.bestScore}\n`;
        
        if (iter.topArticles && iter.topArticles[0]) {
          summaryText += `  ‚Ä¢ Top finding: "${iter.topArticles[0].title.substring(0, 60)}..."\n`;
        }
      });
      
      evolutionDiv.textContent = summaryText;
    }

    // Generate abstract summary
    async function generateAbstractSummary() {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results to summarize.");
        return;
      }
      
      const count = parseInt(document.getElementById("summary-count").value);
      const topArticles = state.searchState.finalRanking.slice(0, count);
      
      const summaryDiv = document.getElementById("summary");
      summaryDiv.textContent = "Generating summary...";
      
      let abstractsText = "";
      topArticles.forEach((article, i) => {
        abstractsText += `\nArticle ${i + 1}: ${article.title}\n`;
        abstractsText += `Authors: ${article.authors.slice(0, 3).join(", ")}\n`;
        abstractsText += `Journal: ${article.journal} (${article.pub_date})\n`;
        abstractsText += `Relevance Score: ${article.relevance_score}/100\n`;
        abstractsText += `Abstract: ${article.abstract || "Not available"}\n`;
        abstractsText += "-".repeat(80) + "\n";
      });
      
      const prompt = `Analyze and synthesize these research articles related to: "${state.config.query}"

${abstractsText}

Provide:
1. KEY FINDINGS: Main discoveries relevant to the query
2. METHODS: Common approaches used
3. CLINICAL RELEVANCE: Practical implications
4. KNOWLEDGE GAPS: What aspects remain unstudied

Be specific about which findings come from which papers.`;
      
      try {
        const summary = await callOpenAI(prompt, 0.3, 1500);
        summaryDiv.textContent = summary;
      } catch (e) {
        summaryDiv.textContent = `Error: ${e.message}`;
      }
    }

    // Handle errors
    function handleSearchError(error) {
      if (error.name === 'AbortError' || error.message === 'Search cancelled') {
        logMessage("\n\n‚ùå Search cancelled by user.\n");
      } else {
        logMessage(`\n\n‚ùå Error: ${error.message}\n`);
      }
    }

    // Clear displays
    function clearAllDisplays() {
      ['iteration-log', 'results', 'summary', 'evolution', 'rankings'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.textContent = '';
          element.innerHTML = '';
        }
      });
      
      document.getElementById('mesh-learning-section').style.display = 'none';
    }

    // Reset search state
    function resetSearchState() {
      state.searchState = {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        meshTermsValidated: {},
        searchHistory: [],
        successfulTerms: new Set(),
        failedSearches: [],
        conceptAnalysis: null,
        searchPatterns: {
          successful: [],
          failed: []
        },
        discoveredMeshTerms: new Set(),
        meshTermFrequency: {},
        relatedFindings: [],
        missingConcepts: []
      };
      tokenCounter.reset();
      updateTokenDisplay();
    }

    // Toggle UI
    function toggleUI(isSearching) {
      document.getElementById("start-btn").disabled = isSearching;
      document.getElementById("start-btn").style.display = isSearching ? 'none' : 'inline-block';
      document.getElementById("cancel-btn").style.display = isSearching ? 'inline-block' : 'none';
      
      const inputs = document.querySelectorAll('input:not(#test-api-btn), select');
      inputs.forEach(el => el.disabled = isSearching);
    }

    // Export results
    function exportResults(format) {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results to export.");
        return;
      }
      
      let content = '';
      let filename = `pubmed_results_${new Date().toISOString().split('T')[0]}`;
      let mimeType = 'text/plain';
      
      if (format === 'json') {
        content = JSON.stringify({
          query: state.config.query,
          date: new Date().toISOString(),
          results: state.searchState.finalRanking,
          meshTermsDiscovered: Array.from(state.searchState.discoveredMeshTerms),
          meshTermFrequency: state.searchState.meshTermFrequency,
          searchHistory: state.searchState.searchHistory,
          conceptAnalysis: state.searchState.conceptAnalysis,
          tokenUsage: {
            input: tokenCounter.inputTokens,
            output: tokenCounter.outputTokens,
            cost: tokenCounter.getCostEstimate(state.config.modelChoice)
          }
        }, null, 2);
        filename += '.json';
        mimeType = 'application/json';
      } else if (format === 'csv') {
        content = 'Rank,PMID,Title,Authors,Journal,Year,Score,MeSH Terms,URL\n';
        state.searchState.finalRanking.forEach((article, i) => {
          content += `${i + 1},`;
          content += `"${article.pmid}",`;
          content += `"${article.title.replace(/"/g, '""')}",`;
          content += `"${article.authors.slice(0, 3).join('; ')}",`;
          content += `"${article.journal.replace(/"/g, '""')}",`;
          content += `${article.pub_date},`;
          content += `${article.relevance_score},`;
          content += `"${(article.meshTerms || []).slice(0, 5).join('; ')}",`;
          content += `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n`;
        });
        filename += '.csv';
        mimeType = 'text/csv';
      } else {
        // Text format
        content = `PUBMED SEARCH RESULTS\n`;
        content += `${"=".repeat(60)}\n\n`;
        content += `Query: ${state.config.query}\n`;
        content += `Date: ${new Date().toLocaleString()}\n`;
        content += `Total Results: ${state.searchState.finalRanking.length}\n\n`;
        
        if (state.searchState.discoveredMeshTerms.size > 0) {
          content += `DISCOVERED MeSH TERMS:\n`;
          const topMesh = Object.entries(state.searchState.meshTermFrequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 15);
          topMesh.forEach(([term, count]) => {
            content += `  ‚Ä¢ ${term} (${count} occurrences)\n`;
          });
          content += '\n';
        }
        
        state.searchState.finalRanking.forEach((article, i) => {
          content += `${i + 1}. ${article.title}\n`;
          content += `   Authors: ${article.authors.join(', ')}\n`;
          content += `   Journal: ${article.journal} (${article.pub_date})\n`;
          content += `   PMID: ${article.pmid}\n`;
          content += `   Score: ${article.relevance_score}/100\n`;
          content += `   MeSH: ${(article.meshTerms || []).slice(0, 5).join(', ')}\n`;
          content += `   URL: https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n`;
          content += `   Abstract: ${article.abstract || 'Not available'}\n`;
          content += `\n${"-".repeat(60)}\n\n`;
        });
        
        filename += '.txt';
      }
      
      // Download
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Test API key
    async function testAPIKey() {
      const apiKey = document.getElementById("api-key").value.trim();
      const resultDiv = document.getElementById("api-test-result");
      
      if (!apiKey) {
        resultDiv.innerHTML = '<div class="api-test-result api-test-failure">‚ùå Please enter an API key</div>';
        return;
      }
      
      resultDiv.innerHTML = '<div class="api-test-result">Testing API key...</div>';
      
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          method: "GET",
          headers: {
            "Authorization": `Bearer ${apiKey}`
          }
        });
        
        if (response.ok) {
          resultDiv.innerHTML = '<div class="api-test-result api-test-success">‚úÖ API key is valid!</div>';
        } else {
          const error = await response.json().catch(() => ({ error: { message: "Invalid key" } }));
          resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå ${error.error?.message || response.statusText}</div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå Connection error: ${error.message}</div>`;
      }
    }

    // HTML escape
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========== Event Listeners ==========
    
    document.getElementById("test-api-btn").addEventListener("click", testAPIKey);
    
    document.getElementById("start-btn").addEventListener("click", () => {
      state.config = {
        openAIKey: document.getElementById("api-key").value.trim(),
        modelChoice: document.getElementById("model-select").value,
        totalIterations: parseInt(document.getElementById("iterations").value),
        articlesPerIteration: parseInt(document.getElementById("articles-per-iter").value),
        topArticlesPerIteration: parseInt(document.getElementById("top-articles").value),
        searchStrategy: document.getElementById("search-strategy").value,
        query: document.getElementById("query-input").value.trim()
      };
      
      if (!state.config.openAIKey) {
        alert("Please enter your OpenAI API key.");
        return;
      }
      
      if (!state.config.query) {
        alert("Please enter a research query.");
        return;
      }
      
      runIterativeSearch(state.config.query);
    });
    
    document.getElementById("cancel-btn").addEventListener("click", () => {
      if (state.abortController) {
        state.abortController.abort();
      }
    });
    
    document.getElementById("summary-btn").addEventListener("click", generateAbstractSummary);
    
    // Initialize
    window.addEventListener('load', () => {
      document.getElementById("query-input").focus();
    });
  </script>
</body>
</html>
