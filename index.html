<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced AI-Powered PubMed Research Tool</title>
  <style>
    /* Enhanced styling for professional appearance */
    * {
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      color: #1a5490;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.2em;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    
    h2, h3 { 
      color: #2E5AAC;
      margin-top: 20px;
    }
    
    /* Enhanced form styling */
    label { 
      font-weight: 600;
      display: inline-block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #495057;
    }
    
    input, select, button, textarea { 
      margin: 5px 0;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4dabf7;
      box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.1);
    }
    
    button {
      cursor: pointer;
      background-color: #228be6;
      color: white;
      border: none;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    button:hover:not(:disabled) {
      background-color: #1971c2;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    button:disabled { 
      background-color: #e9ecef;
      color: #868e96;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Section styling */
    .section { 
      background: white;
      border: 1px solid #dee2e6;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Tab system */
    .tabs {
      display: flex;
      border-bottom: 2px solid #dee2e6;
      margin-bottom: 20px;
      background: white;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }
    
    .tab {
      padding: 12px 24px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-weight: 600;
      color: #495057;
      transition: all 0.3s ease;
      flex: 1;
      text-align: center;
    }
    
    .tab:hover {
      background: #e9ecef;
    }
    
    .tab.active {
      background: white;
      color: #228be6;
      border-bottom: 3px solid #228be6;
      margin-bottom: -2px;
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Status indicators */
    #progress-status { 
      font-style: italic;
      color: #495057;
      margin-top: 10px;
      padding: 10px;
      background: #e7f5ff;
      border-radius: 5px;
      display: inline-block;
    }
    
    /* Output areas */
    .output-area {
      width: 100%;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      background: #f8f9fa;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      line-height: 1.5;
    }
    
    #iteration-log {
      max-height: 500px;
    }
    
    /* Special highlighting */
    .invalid-mesh { 
      background-color: #ffe0e0;
      color: #c92a2a;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #ffa8a8;
    }
    
    .key-concept {
      background-color: #fff3cd;
      color: #856404;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    .good-score {
      color: #2b8a3e;
      font-weight: bold;
    }
    
    .medium-score {
      color: #e67700;
      font-weight: bold;
    }
    
    .poor-score {
      color: #c92a2a;
      font-weight: bold;
    }
    
    /* API test result styling */
    .api-test-result {
      margin: 10px 0;
      padding: 12px;
      border-radius: 5px;
      font-weight: 500;
    }
    
    .api-test-success {
      background-color: #d3f9d8;
      color: #2b8a3e;
      border: 1px solid #8ce99a;
    }
    
    .api-test-failure {
      background-color: #ffe0e0;
      color: #c92a2a;
      border: 1px solid #ffa8a8;
    }
    
    /* CORS warning */
    #cors-warning {
      background-color: #fff3cd;
      border: 1px solid #ffec99;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    
    #cors-warning code {
      background-color: #f8f9fa;
      padding: 3px 6px;
      border-radius: 3px;
      font-family: monospace;
      border: 1px solid #dee2e6;
    }
    
    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #228be6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Token display */
    .token-display {
      background: #e7f5ff;
      padding: 8px 15px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      display: inline-block;
      border: 1px solid #74c0fc;
      margin-left: 20px;
    }
    
    /* Concept tracking */
    .concept-tag {
      display: inline-block;
      background: #e9ecef;
      padding: 4px 10px;
      margin: 2px;
      border-radius: 15px;
      font-size: 12px;
      border: 1px solid #ced4da;
    }
    
    .concept-tag.primary {
      background: #74c0fc;
      color: white;
      border-color: #339af0;
    }
    
    /* Results styling */
    .article-result {
      background: #f8f9fa;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .article-result h4 {
      margin: 0 0 10px 0;
      color: #1a5490;
    }
    
    .article-metadata {
      font-size: 13px;
      color: #6c757d;
      margin: 5px 0;
    }
    
    .article-abstract {
      margin-top: 10px;
      font-style: italic;
      color: #495057;
      line-height: 1.6;
    }
    
    /* Buttons */
    .primary-button {
      background-color: #228be6;
      font-size: 16px;
      padding: 12px 24px;
      margin: 10px 0;
    }
    
    .secondary-button {
      background-color: #495057;
      font-size: 14px;
      padding: 8px 16px;
    }
    
    .success-button {
      background-color: #2b8a3e;
    }
    
    .warning-button {
      background-color: #e67700;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .tabs {
        flex-direction: column;
      }
      
      .tab {
        border-bottom: 1px solid #dee2e6;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üî¨ Enhanced AI-Powered PubMed Research Tool</h1>
    
    <!-- Tab Navigation -->
    <div class="tabs">
      <!-- FIX: Added 'event' to the function call for all tab buttons -->
      <button class="tab active" onclick="showTab(event, 'search')">üîç Search</button>
      <button class="tab" onclick="showTab(event, 'results')">üìä Results</button>
      <button class="tab" onclick="showTab(event, 'evolution')">üß¨ Evolution</button>
      <button class="tab" onclick="showTab(event, 'config')">‚öôÔ∏è Configuration</button>
    </div>
    
    <!-- Search Tab -->
    <div id="search-tab" class="tab-content active">
      <!-- Configuration Section -->
      <div class="section" id="config-section">
        <h2>Configuration</h2>
        
        <!-- CORS Warning (shown only when running locally) -->
        <div id="cors-warning" style="display:none;">
          <strong>‚ö†Ô∏è Local File Detected - CORS Issues Expected</strong><br>
          <p style="margin:5px 0;">This tool needs to be hosted online to work properly. Quick solutions:</p>
          <ol style="margin:5px 0 5px 20px;">
            <li><strong>GitHub Pages</strong>: Upload to GitHub, enable Pages (free)</li>
            <li><strong>Netlify</strong>: Drag file to <a href="https://netlify.com" target="_blank">netlify.com</a></li>
            <li><strong>Local Server</strong>: Run <code>python -m http.server 8000</code></li>
          </ol>
        </div>
        
        <!-- API Key Input -->
        <label for="api-key">OpenAI API Key:</label><br>
        <input type="password" id="api-key" placeholder="Enter your OpenAI API key" size="50" />
        <button id="test-api-btn" style="margin-left: 10px;">Test API Key</button>
        <div id="api-test-result"></div>
        <p style="font-size: 0.9em; color: #666; margin-top: 5px;">
          * Your API key is used client-side only and is NOT stored.<br>
          * Supports all OpenAI API key formats (sk-, sk-proj-, etc.)
        </p>
        
        <!-- Model Selection -->
        <label for="model-select">AI Model:</label>
        <select id="model-select" style="margin-left: 10px;">
          <option value="gpt-4-turbo">GPT-4 Turbo (Recommended)</option>
          <option value="gpt-4o">GPT-4o</option>
          <option value="gpt-4o-mini">GPT-4o Mini</option>
          <option value="gpt-4">GPT-4</option>
          <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
        </select>
        
        <!-- Token Display -->
        <div class="token-display" id="token-display">
          üî§ Tokens - In: 0 | Out: 0 | Est. Cost: $0.00
        </div>
      </div>

      <!-- Query Section -->
      <div class="section" id="query-section">
        <h2>Research Query</h2>
        <label for="query-input">Enter your medical research question:</label><br>
        <input type="text" id="query-input" size="80" placeholder="e.g. 'Pard3 knockout mice experiments to show polarity of cells in cornea'" 
               style="width: 100%; font-size: 16px; padding: 10px;" />
        
        <!-- Identified Concepts Display -->
        <div id="concept-display" style="margin-top: 15px; display: none;">
          <label>Identified Key Concepts:</label>
          <div id="concept-tags"></div>
        </div>
        
        <h3>Search Parameters</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <div>
            <label for="iterations">Iterations:</label>
            <input type="number" id="iterations" value="4" min="2" max="8" style="width:60px;" />
          </div>
          
          <div>
            <label for="articles-per-iter">Articles per iteration:</label>
            <input type="number" id="articles-per-iter" value="20" min="10" max="50" style="width:60px;" />
          </div>
          
          <div>
            <label for="top-articles">Top articles to analyze:</label>
            <input type="number" id="top-articles" value="8" min="3" max="15" style="width:60px;" />
          </div>
          
          <div>
            <label for="exploration-factor">Exploration factor:</label>
            <select id="exploration-factor">
              <option value="conservative">Conservative (0.2)</option>
              <option value="balanced" selected>Balanced (0.4)</option>
              <option value="explorative">Explorative (0.6)</option>
            </select>
          </div>
        </div>
        
        <button id="start-btn" class="primary-button" style="margin-top: 20px;">
          üîç Start Enhanced Iterative Search
        </button>
        <button id="cancel-btn" class="primary-button warning-button" style="display:none;">
          ‚ùå Cancel Search
        </button>
        <span id="progress-status"></span>
      </div>

      <!-- Progress Log Section -->
      <div class="section" id="log-section">
        <h2>Iteration Progress</h2>
        <div id="iteration-log" class="output-area" aria-live="polite"></div>
      </div>
    </div>
    
    <!-- Results Tab -->
    <div id="results-tab" class="tab-content">
      <div class="section" id="results-section">
        <h2>Top Articles with Abstracts</h2>
        <div id="results" class="output-area"></div>
        
        <h3>AI Summary of Top Articles</h3>
        <div style="margin: 10px 0;">
          <label for="summary-count">Summarize top</label>
          <input type="number" id="summary-count" value="5" min="3" max="15" style="width:50px;" /> articles
          <button id="summary-btn" class="secondary-button" style="margin-left: 10px;">Generate Summary</button>
        </div>
        <div id="summary" class="output-area"></div>
      </div>
    </div>
    
    <!-- Evolution Tab -->
    <div id="evolution-tab" class="tab-content">
      <div class="section" id="evolution-section">
        <h2>Search Evolution Overview</h2>
        <div id="evolution" class="output-area"></div>
        
        <h3>Concept Evolution</h3>
        <div id="concept-evolution" class="output-area"></div>
        
        <h3>Complete Article Rankings</h3>
        <div id="rankings" class="output-area"></div>
      </div>
    </div>
    
    <!-- Configuration Tab -->
    <div id="config-tab" class="tab-content">
      <div class="section">
        <h2>Advanced Configuration</h2>
        <h3>Search Strategy Settings</h3>
        
        <label>
          <input type="checkbox" id="use-mesh-expansion" checked> 
          Enable MeSH term expansion
        </label><br>
        
        <label>
          <input type="checkbox" id="use-synonym-search" checked> 
          Enable synonym searching
        </label><br>
        
        <label>
          <input type="checkbox" id="use-concept-clustering" checked> 
          Enable concept clustering
        </label><br>
        
        <label>
          <input type="checkbox" id="use-self-reflection" checked> 
          Enable AI self-reflection on relevance
        </label><br>
        
        <h3>Export Options</h3>
        <button onclick="exportResults('json')" class="secondary-button">Export as JSON</button>
        <button onclick="exportResults('csv')" class="secondary-button">Export as CSV</button>
        <button onclick="exportResults('txt')" class="secondary-button">Export as Text</button>
      </div>
    </div>
  </div>

  <script>
    // ========== Enhanced Prompt Templates with Self-Reflection ==========
    const PromptTemplates = {
      // Extract key concepts from the query
      EXTRACT_CONCEPTS: `Analyze this medical research query and extract the key concepts, entities, and relationships: "{query}"

Identify:
1. PRIMARY CONCEPTS: Core medical/biological terms that MUST appear in relevant articles
2. SECONDARY CONCEPTS: Related terms that enhance relevance
3. METHODOLOGICAL TERMS: Experimental approaches, techniques
4. ORGANISM/MODEL: Specific organisms, cell types, or models
5. RELATIONSHIPS: How concepts relate to each other

Also suggest:
- Synonyms for each concept
- Related MeSH terms
- Alternative spellings/nomenclature

Return as JSON:
{
  "primary_concepts": ["concept1", "concept2"],
  "secondary_concepts": ["concept3", "concept4"],
  "methodological_terms": ["method1", "method2"],
  "organism_model": ["organism1"],
  "synonyms": {
    "concept1": ["syn1", "syn2"],
    "concept2": ["syn3", "syn4"]
  },
  "mesh_terms": {
    "concept1": ["MeSH1", "MeSH2"],
    "concept2": ["MeSH3"]
  }
}`,

      // Generate complex boolean searches
      GENERATE_COMPLEX_SEARCHES: `Based on these concepts and search history, generate 5 sophisticated PubMed search strategies:

Concepts: {concepts}
Previous searches: {previous_searches}
Previous lessons: {lessons}

Create searches that:
1. Use complex boolean logic: (A OR B) AND (C OR D)
2. Substitute synonyms strategically
3. Balance specificity and recall
4. Target different aspects of the research question
5. Learn from what worked/didn't work before

Use proper PubMed syntax with [MeSH], [tiab], quotations, etc.

IMPORTANT: Each search should explore a different combination of concepts.

Return only a JSON array of search strings.`,

      // Self-reflection on search relevance
      SELF_REFLECTION: `Reflect on the relevance of these search strategies for the query: "{query}"

Search strategies:
{strategies}

For each strategy, consider:
1. Does it capture the core intent of the query?
2. Is it too broad or too narrow?
3. Are key concepts properly represented?
4. What might it miss?
5. Relevance score (0-100)

Return JSON:
[
  {
    "strategy_index": 1,
    "relevance_score": 85,
    "captures_intent": true,
    "potential_issues": "May be too specific on methodology",
    "missing_aspects": "Doesn't include related cell types",
    "recommendation": "Keep but add broader cell biology terms"
  }
]`,

      // Enhanced article analysis with concept tracking
      ARTICLE_ANALYSIS_ENHANCED: `Analyze these articles for relevance to: "{query}"

Key concepts to track: {concepts}

For each article:
1. Relevance score (0-100)
2. Which key concepts are present/absent?
3. How well does it address the research question?
4. What unique insights does it provide?
5. Methodological relevance

Articles:
{articles}

Return JSON:
[
  {
    "index": 1,
    "score": 85,
    "concepts_present": ["Pard3", "knockout", "polarity"],
    "concepts_missing": ["cornea"],
    "reasoning": "Directly studies Pard3 knockout effects on cell polarity...",
    "unique_insights": "Novel mechanism for...",
    "methodological_match": true
  }
]`,

      // Iteration insights with concept evolution
      ITERATION_INSIGHTS_ENHANCED: `Analyze iteration {iteration} for query: "{query}"

Key concepts tracked: {concepts}
Search terms used: {search_terms}
Top articles found: {articles_summary}

Provide:

CONCEPT EVOLUTION:
- Which concepts yielded good results?
- Which concepts need refinement?
- New related concepts discovered?

SEARCH EFFECTIVENESS:
- What search patterns worked well?
- What combinations were too broad/narrow?

LESSONS LEARNED:
- Key insights for next iteration
- Dead ends to avoid

NEXT STRATEGY:
- Specific concept combinations to try
- New angles to explore
- Refinements needed

Keep responses concise but actionable.`,

      // Final ranking with concept coverage
      FINAL_RANKING_ENHANCED: `Perform comprehensive ranking for query: "{query}"

Consider:
1. Concept coverage (which articles cover most key concepts)
2. Methodological relevance
3. Direct applicability to research question
4. Quality indicators (journal, recency, citations implied by methodology)
5. Unique contributions

Articles: {articles}

Rank ALL {count} articles from most to least relevant.
Return as JSON array of article numbers: [3, 1, 7, 2, ...]`,

      // Generate comprehensive summary
      SEARCH_SUMMARY_ENHANCED: `Create an executive summary of this iterative search:

Query: {query}
Key concepts identified: {concepts}
Search evolution: {evolution_data}

Provide:
1. CONCEPT LANDSCAPE: How key concepts relate in the literature
2. SEARCH EFFECTIVENESS: Which strategies worked best and why
3. KNOWLEDGE GAPS: What's missing in the literature
4. RECOMMENDATIONS: Next steps for research

Keep it concise but insightful (3-4 paragraphs).`,

      ABSTRACT_SUMMARY: `Analyze and synthesize these research articles:

{abstracts}

Create a comprehensive summary covering:
1. OVERVIEW: Main themes and consensus findings
2. KEY DISCOVERIES: Most important results across all papers
3. METHODOLOGICAL APPROACHES: Common techniques and innovations
4. CLINICAL/BIOLOGICAL SIGNIFICANCE: Real-world implications
5. CONTRADICTIONS: Any conflicting findings
6. FUTURE DIRECTIONS: Gaps and opportunities identified

Make it accessible yet thorough for researchers.`
    };

    // ========== Global State Management ==========
    let state = {
      config: {},
      searchState: {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        totalInputTokens: 0,
        totalOutputTokens: 0,
        keyConcepts: null,
        conceptEvolution: {},
        searchHistory: []
      },
      abortController: null,
      currentTab: 'search'
    };

    // ========== Enhanced Token Counter ==========
    class TokenCounter {
      constructor() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
      
      // More accurate token estimation
      estimateTokens(text) {
        // Better approximation: ~1 token per 4 characters for English
        // Adjust for code/special characters
        const baseCount = text.length / 4;
        const specialChars = (text.match(/[{}\[\]"':,]/g) || []).length;
        return Math.ceil(baseCount + specialChars * 0.5);
      }
      
      addApiCall(prompt, response) {
        this.inputTokens += this.estimateTokens(prompt);
        this.outputTokens += this.estimateTokens(response);
        updateTokenDisplay();
      }
      
      getCostEstimate(model = "gpt-4-turbo") {
        // Updated pricing as of 2024
        const pricing = {
          "gpt-4-turbo": { input: 0.01, output: 0.03 },
          "gpt-4o": { input: 0.005, output: 0.015 },
          "gpt-4o-mini": { input: 0.00015, output: 0.0006 },
          "gpt-4": { input: 0.03, output: 0.06 },
          "gpt-3.5-turbo": { input: 0.0005, output: 0.0015 }
        };
        
        const modelPricing = pricing[model] || pricing["gpt-4-turbo"];
        const inputCost = (this.inputTokens / 1000) * modelPricing.input;
        const outputCost = (this.outputTokens / 1000) * modelPricing.output;
        
        return inputCost + outputCost;
      }
      
      reset() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
    }

    // Initialize token counter
    const tokenCounter = new TokenCounter();

    // ========== Core Configuration ==========
    const CORS_PROXIES = [
      'https://corsproxy.io/?',
      'https://api.codetabs.com/v1/proxy?quest=',
      'https://proxy.cors.sh/',
      'https://api.allorigins.win/raw?url='
    ];
    let currentProxyIndex = 0;
    const NCBI_REQUEST_DELAY_MS = 400;

    // Detect if running locally
    const isRunningLocally = window.location.protocol === 'file:';

    // ========== Enhanced Helper Functions ==========
    
    // Tab management
    // FIX: Function signature updated to accept 'event' and 'tabName'.
    // FIX: 'event.currentTarget' is now used to correctly identify the clicked button.
    function showTab(event, tabName) {
      // Hide all tab content and remove 'active' from all tab buttons
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show the selected tab's content
      document.getElementById(`${tabName}-tab`).classList.add('active');
      
      // Add 'active' class to the clicked button
      event.currentTarget.classList.add('active');
      
      state.currentTab = tabName;
    }

    // Enhanced logging with categorization
    function logMessage(message, category = 'info', isHtml = false) {
      const logArea = document.getElementById("iteration-log");
      const timestamp = new Date().toLocaleTimeString();
      
      let formattedMessage = message;
      if (category === 'error') {
        formattedMessage = `‚ùå ${message}`;
      } else if (category === 'success') {
        formattedMessage = `‚úÖ ${message}`;
      } else if (category === 'warning') {
        formattedMessage = `‚ö†Ô∏è ${message}`;
      } else if (category === 'concept') {
        formattedMessage = `üß¨ ${message}`;
      }
      
      if (isHtml) {
        logArea.innerHTML += `<span class="log-${category}">[${timestamp}] ${formattedMessage}</span>`;
      } else {
        logArea.textContent += `[${timestamp}] ${formattedMessage}`;
      }
      logArea.scrollTop = logArea.scrollHeight;
    }

    // Update token display
    function updateTokenDisplay() {
      const cost = tokenCounter.getCostEstimate(state.config.modelChoice);
      const display = document.getElementById("token-display");
      display.textContent = `üî§ Tokens - In: ${tokenCounter.inputTokens.toLocaleString()} | Out: ${tokenCounter.outputTokens.toLocaleString()} | Est. Cost: $${cost.toFixed(4)}`;
    }

    // Display key concepts
    function displayKeyConcepts(concepts) {
      const conceptDisplay = document.getElementById("concept-display");
      const conceptTags = document.getElementById("concept-tags");
      
      conceptDisplay.style.display = 'block';
      conceptTags.innerHTML = '';
      
      // Primary concepts
      concepts.primary_concepts.forEach(concept => {
        const tag = document.createElement('span');
        tag.className = 'concept-tag primary';
        tag.textContent = concept;
        conceptTags.appendChild(tag);
      });
      
      // Secondary concepts
      concepts.secondary_concepts.forEach(concept => {
        const tag = document.createElement('span');
        tag.className = 'concept-tag';
        tag.textContent = concept;
        conceptTags.appendChild(tag);
      });
    }

    // Enhanced OpenAI API call with better error handling
    async function callOpenAI(prompt, temperature = 0.3, maxTokens = 1000) {
      const requestBody = {
        model: state.config.modelChoice,
        messages: [{ role: "user", content: prompt }],
        temperature: temperature,
        max_tokens: maxTokens
      };
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${state.config.openAIKey}`
          },
          body: JSON.stringify(requestBody),
          signal: state.abortController?.signal
        });
        
        const responseText = await response.text();
        
        if (!response.ok) {
          let errorMessage = `OpenAI API Error: ${response.status} ${response.statusText}`;
          try {
            const errorData = JSON.parse(responseText);
            if (errorData.error?.message) {
              errorMessage = `OpenAI API Error: ${errorData.error.message}`;
            }
          } catch (e) {
            errorMessage += `\nResponse: ${responseText.substring(0, 200)}`;
          }
          throw new Error(errorMessage);
        }
        
        const data = JSON.parse(responseText);
        
        if (!data.choices || data.choices.length === 0) {
          throw new Error("No response from OpenAI API");
        }
        
        let text = data.choices[0].message.content.trim();
        
        // Clean up JSON responses
        text = text.replace(/^```json\s*/, "").replace(/```$/, "").trim();
        text = text.replace(/^```\s*/, "").replace(/```$/, "").trim();
        
        // Track tokens
        tokenCounter.addApiCall(prompt, text);
        
        return text;
      } catch (error) {
        if (error.name === 'AbortError') {
          logMessage("API call cancelled by user.", 'warning');
        } else {
          logMessage(`API call failed: ${error.message}`, 'error');
        }
        throw error;
      }
    }

    // ... (The rest of the JavaScript code is unchanged and remains here)
    // ...
    // Extract key concepts from query
    async function extractKeyConcepts(query) {
      logMessage("\nüß¨ EXTRACTING KEY CONCEPTS\n" + "=".repeat(50) + "\n", 'concept');
      
      const prompt = PromptTemplates.EXTRACT_CONCEPTS.replace("{query}", query);
      
      try {
        const response = await callOpenAI(prompt, 0.3, 800);
        const concepts = JSON.parse(response);
        
        logMessage("Identified key concepts:\n", 'concept');
        logMessage(`  Primary: ${concepts.primary_concepts.join(", ")}\n`, 'concept');
        logMessage(`  Secondary: ${concepts.secondary_concepts.join(", ")}\n`, 'concept');
        logMessage(`  Methods: ${concepts.methodological_terms.join(", ")}\n`, 'concept');
        
        state.searchState.keyConcepts = concepts;
        displayKeyConcepts(concepts);
        
        return concepts;
      } catch (e) {
        logMessage(`Failed to extract concepts: ${e.message}`, 'error');
        // Fallback to basic concept extraction
        const words = query.split(/\s+/);
        return {
          primary_concepts: words.slice(0, 3),
          secondary_concepts: words.slice(3),
          methodological_terms: [],
          organism_model: [],
          synonyms: {},
          mesh_terms: {}
        };
      }
    }

    // Generate complex boolean searches
    async function generateComplexSearches(iteration, query, concepts) {
      logMessage("\nüîç GENERATING COMPLEX SEARCH STRATEGIES\n", 'info');
      
      const context = {
        concepts: JSON.stringify(concepts),
        previous_searches: JSON.stringify(state.searchState.searchHistory.slice(-10)),
        lessons: state.searchState.iterationsData.slice(-2).map(d => d.lessons).join("; ")
      };
      
      const prompt = PromptTemplates.GENERATE_COMPLEX_SEARCHES
        .replace("{concepts}", context.concepts)
        .replace("{previous_searches}", context.previous_searches)
        .replace("{lessons}", context.lessons);
      
      try {
        const response = await callOpenAI(prompt, 0.4, 800);
        let searches = JSON.parse(response);
        
        // Apply self-reflection if enabled
        if (document.getElementById('use-self-reflection').checked) {
          searches = await reflectOnSearchRelevance(query, searches);
        }
        
        return searches;
      } catch (e) {
        logMessage(`Failed to generate complex searches: ${e.message}`, 'error');
        // Fallback to simple search
        return [query.split(" ").join(" AND ")];
      }
    }

    // Self-reflection on search relevance
    async function reflectOnSearchRelevance(query, strategies) {
      logMessage("ü§î Reflecting on search relevance...\n", 'info');
      
      const prompt = PromptTemplates.SELF_REFLECTION
        .replace("{query}", query)
        .replace("{strategies}", JSON.stringify(strategies));
      
      try {
        const response = await callOpenAI(prompt, 0.2, 600);
        const reflections = JSON.parse(response);
        
        // Filter and refine strategies based on reflection
        const refinedStrategies = [];
        reflections.forEach((reflection, index) => {
          if (reflection.relevance_score >= 60) {
            refinedStrategies.push(strategies[index]);
            if (reflection.recommendation.includes("add")) {
              logMessage(`  Strategy ${index + 1}: Good (${reflection.relevance_score}/100) - ${reflection.recommendation}\n`, 'success');
            }
          } else {
            logMessage(`  Strategy ${index + 1}: Poor (${reflection.relevance_score}/100) - Skipping\n`, 'warning');
          }
        });
        
        return refinedStrategies.length > 0 ? refinedStrategies : strategies.slice(0, 3);
      } catch (e) {
        logMessage(`Self-reflection failed: ${e.message}`, 'warning');
        return strategies;
      }
    }

    // Enhanced fetch with CORS proxy
    async function cancellableFetch(url, options = {}) {
      let lastError;
      
      // Show warning if running locally (only once)
      if (isRunningLocally && !window.corsWarningShown) {
        logMessage("Running from local file detected. CORS proxies may be limited.\n", 'warning');
        logMessage("For best results, use a local web server or host online.\n", 'warning');
        window.corsWarningShown = true;
      }
      
      // Try direct fetch first for non-NCBI URLs
      if (!url.includes('ncbi.nlm.nih.gov')) {
        try {
          const response = await fetch(url, { ...options, signal: state.abortController?.signal });
          if (response.ok) return response;
        } catch (e) {
          // Continue to proxy attempts
        }
      }
      
      // Try each CORS proxy
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
        const proxy = CORS_PROXIES[proxyIndex];
        const proxiedUrl = proxy + encodeURIComponent(url);
        
        try {
          const response = await fetch(proxiedUrl, { ...options, signal: state.abortController?.signal });
          if (response.ok) {
            currentProxyIndex = proxyIndex;
            return response;
          }
          lastError = new Error(`Proxy ${proxy} returned status ${response.status}`);
        } catch (error) {
          lastError = error;
          if (error.name === 'AbortError') throw error;
        }
      }
      
      logMessage(`All CORS proxies failed. ${isRunningLocally ? 'Please host this file online.' : 'Try again later.'}`, 'error');
      throw lastError || new Error('All CORS proxies failed');
    }

    // Enhanced PubMed search
    async function searchPubMed(query, maxResults = 20) {
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(query)}&retmode=xml&retmax=${maxResults}&tool=Enhanced_AI_PubMed_Searcher&email=research.tool@example.com&sort=relevance`;
      
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) throw new Error(`PubMed search error: ${resp.status}`);
        
        const xmlText = await resp.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "text/xml");
        
        const errorNode = xmlDoc.querySelector("ERROR");
        if (errorNode) {
          throw new Error(`PubMed API error: ${errorNode.textContent}`);
        }
        
        const idElements = Array.from(xmlDoc.getElementsByTagName("Id"));
        return idElements.map(idNode => idNode.textContent);
      } catch (error) {
        if (error.name !== 'AbortError') {
          logMessage(`PubMed search error: ${error.message}`, 'error');
        }
        return [];
      }
    }

    // Fetch PubMed article details
    async function fetchPubMedDetails(pmids) {
      if (pmids.length === 0) return [];
      
      const BATCH_SIZE = 100;
      let articles = [];
      
      for (let i = 0; i < pmids.length; i += BATCH_SIZE) {
        const batchIds = pmids.slice(i, i + BATCH_SIZE).join(",");
        const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${batchIds}&retmode=xml&tool=Enhanced_AI_PubMed_Searcher&email=research.tool@example.com`;
        
        try {
          const resp = await cancellableFetch(url);
          if (!resp.ok) throw new Error(`PubMed fetch error: ${resp.status}`);
          
          const xmlText = await resp.text();
          const xmlDoc = new DOMParser().parseFromString(xmlText, "text/xml");
          const articleNodes = Array.from(xmlDoc.getElementsByTagName("PubmedArticle"));
          
          articles.push(...articleNodes.map(parseArticleXML));
        } catch (error) {
          if (error.name !== 'AbortError') {
            logMessage(`PubMed fetch error: ${error.message}`, 'error');
          }
        }
      }
      
      return articles;
    }

    // Parse article XML
    function parseArticleXML(articleNode) {
      function textOrDefault(elem, tag, defaultVal = "") {
        const node = elem.getElementsByTagName(tag)[0];
        return node && node.textContent ? node.textContent : defaultVal;
      }
      
      const pmid = textOrDefault(articleNode, "PMID", "Unknown");
      const title = textOrDefault(articleNode, "ArticleTitle", "No Title Available");
      
      const authors = Array.from(articleNode.getElementsByTagName("Author")).map(auth => {
        const lastName = textOrDefault(auth, "LastName");
        const foreName = textOrDefault(auth, "ForeName");
        return lastName ? (foreName ? `${lastName}, ${foreName}` : lastName) : null;
      }).filter(Boolean);
      
      const journal = textOrDefault(articleNode, "Title", "Unknown Journal");
      
      const pubDateNode = articleNode.getElementsByTagName("PubDate")[0];
      let pubYear = "Unknown";
      if (pubDateNode) {
        const year = textOrDefault(pubDateNode, "Year");
        const medlineDate = textOrDefault(pubDateNode, "MedlineDate");
        pubYear = year || (medlineDate ? medlineDate.substring(0, 4) : "Unknown");
      }
      
      // Extract full abstract with structure
      const abstractTexts = [];
      const abstractNodes = articleNode.getElementsByTagName("AbstractText");
      for (const node of abstractNodes) {
        const label = node.getAttribute("Label");
        const text = node.textContent;
        if (text) {
          abstractTexts.push(label ? `${label}: ${text}` : text);
        }
      }
      const abstract = abstractTexts.join(" ").trim();
      
      return {
        pmid,
        title,
        authors,
        journal,
        pub_date: pubYear,
        abstract,
        relevance_score: 0,
        ai_reasoning: "",
        found_in_iteration: 0,
        concepts_present: [],
        concepts_missing: [],
        unique_insights: ""
      };
    }

    // Enhanced article analysis with concept tracking
    async function analyzeArticlesEnhanced(query, articlesList, concepts) {
      if (articlesList.length === 0) return [];
      
      logMessage("ü§ñ Analyzing articles with enhanced concept tracking...\n", 'info');
      
      const articleInfo = articlesList.map((a, i) => ({
        index: i + 1,
        pmid: a.pmid,
        title: a.title,
        abstract: (a.abstract || "").substring(0, 1000) + (a.abstract?.length > 1000 ? "..." : ""),
        journal: a.journal,
        year: a.pub_date
      }));
      
      const prompt = PromptTemplates.ARTICLE_ANALYSIS_ENHANCED
        .replace("{query}", query)
        .replace("{concepts}", JSON.stringify(concepts))
        .replace("{articles}", JSON.stringify(articleInfo, null, 2));
      
      try {
        const responseText = await callOpenAI(prompt, 0.2, 2000);
        const results = JSON.parse(responseText);
        
        results.forEach(res => {
          if (articlesList[res.index - 1]) {
            const article = articlesList[res.index - 1];
            article.relevance_score = res.score || 0;
            article.ai_reasoning = res.reasoning || "No reasoning provided.";
            article.concepts_present = res.concepts_present || [];
            article.concepts_missing = res.concepts_missing || [];
            article.unique_insights = res.unique_insights || "";
            article.methodological_match = res.methodological_match || false;
          }
        });
        
        // Update concept evolution tracking
        updateConceptEvolution(results);
        
      } catch (e) {
        logMessage(`AI analysis failed: ${e.message}. Using fallback scoring.`, 'error');
        articlesList.forEach(a => {
          a.relevance_score = 50;
          a.ai_reasoning = "AI analysis failed - fallback scoring applied.";
        });
      }
      
      return articlesList;
    }

    // Track concept evolution
    function updateConceptEvolution(analysisResults) {
      if (!state.searchState.conceptEvolution) {
        state.searchState.conceptEvolution = {};
      }
      
      analysisResults.forEach(result => {
        result.concepts_present.forEach(concept => {
          if (!state.searchState.conceptEvolution[concept]) {
            state.searchState.conceptEvolution[concept] = {
              frequency: 0,
              avgScore: 0,
              articles: []
            };
          }
          const evolution = state.searchState.conceptEvolution[concept];
          evolution.frequency++;
          evolution.avgScore = ((evolution.avgScore * (evolution.frequency - 1)) + result.score) / evolution.frequency;
          evolution.articles.push(result.index);
        });
      });
    }

    // Enhanced iteration insights
    async function getIterationInsightsEnhanced(query, iter, searchTerms, topArticles, concepts) {
      const summary = topArticles.slice(0, 5).map((a, i) => 
        `${i + 1}. ${a.title} (Score: ${a.relevance_score.toFixed(0)}, Concepts: ${a.concepts_present.join(", ")})`
      ).join("\n");
      
      const prompt = PromptTemplates.ITERATION_INSIGHTS_ENHANCED
        .replace("{query}", query)
        .replace("{iteration}", iter)
        .replace("{concepts}", JSON.stringify(concepts))
        .replace("{search_terms}", JSON.stringify(searchTerms))
        .replace("{articles_summary}", summary);
      
      try {
        const responseText = await callOpenAI(prompt, 0.3, 800);
        
        // Parse structured response
        const conceptEvolution = responseText.match(/CONCEPT EVOLUTION:([\s\S]*?)SEARCH EFFECTIVENESS:/)?.[1]?.trim() || "";
        const searchEffectiveness = responseText.match(/SEARCH EFFECTIVENESS:([\s\S]*?)LESSONS LEARNED:/)?.[1]?.trim() || "";
        const lessons = responseText.match(/LESSONS LEARNED:([\s\S]*?)NEXT STRATEGY:/)?.[1]?.trim() || "";
        const nextStrategy = responseText.match(/NEXT STRATEGY:([\s\S]*)/)?.[1]?.trim() || "";
        
        return { conceptEvolution, searchEffectiveness, lessons, nextStrategy };
      } catch (e) {
        logMessage(`Insights generation failed: ${e.message}`, 'error');
        return {
          conceptEvolution: "Unable to analyze concept evolution",
          searchEffectiveness: "Unable to analyze effectiveness",
          lessons: "Continue with current approach",
          nextStrategy: "Maintain search strategy"
        };
      }
    }

    // Verify MeSH terms
    async function verifyMeshTerm(term) {
      const url = `https://id.nlm.nih.gov/mesh/lookup/descriptor?label=${encodeURIComponent(term)}&match=exact&limit=1`;
      
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) return false;
        
        const data = await resp.json();
        return Array.isArray(data) && data.length > 0 && data[0].label === term;
      } catch (error) {
        console.warn("MeSH verification error:", error);
        return false;
      }
    }

    // Main enhanced iterative search function
    async function runEnhancedIterativeSearch(query) {
      toggleUI(true);
      resetSearchState();
      state.abortController = new AbortController();
      
      // Clear displays
      clearAllDisplays();
      
      logMessage(`üöÄ Starting enhanced iterative search for: "${query}"\n`, 'success');
      logMessage("=" * 80 + "\n");
      
      try {
        // Step 1: Extract key concepts
        const concepts = await extractKeyConcepts(query);
        
        // Main iteration loop
        for (let iter = 1; iter <= state.config.totalIterations; iter++) {
          if (state.abortController.signal.aborted) {
            throw new Error("Search cancelled");
          }
          
          logMessage(`\n\nüîÑ ITERATION ${iter}/${state.config.totalIterations}\n`, 'info');
          logMessage("-" * 50 + "\n");
          
          // Generate complex search strategies
          const searchTerms = await generateComplexSearches(iter, query, concepts);
          
          // Verify MeSH terms if enabled
          if (document.getElementById('use-mesh-expansion').checked) {
            await verifyAndHighlightMeshTerms(searchTerms);
          }
          
          // Execute searches
          logMessage("\nüì° Searching PubMed...\n", 'info');
          const pmidResults = await executeSearchStrategies(searchTerms);
          
          // Process results
          const { newArticles, currentArticles } = await processSearchResults(pmidResults, iter);
          
          if (currentArticles.length === 0) {
            logMessage("No articles found this iteration. Adjusting strategy...\n", 'warning');
            continue;
          }
          
          // Analyze articles with concept tracking
          const analyzedArticles = await analyzeArticlesEnhanced(query, currentArticles, concepts);
          analyzedArticles.sort((a, b) => b.relevance_score - a.relevance_score);
          
          const topArticles = analyzedArticles.slice(0, state.config.topArticlesPerIteration);
          
          // Get enhanced insights
          const insights = await getIterationInsightsEnhanced(query, iter, searchTerms, topArticles, concepts);
          
          // Display iteration summary
          displayIterationSummary(iter, topArticles, insights);
          
          // Store iteration data
          state.searchState.iterationsData.push({
            number: iter,
            searchTerms,
            topArticles,
            ...insights,
            uniqueArticles: currentArticles.length,
            newArticles: newArticles.length
          });
          
          // Update search history
          state.searchState.searchHistory.push(...searchTerms);
        }
        
        // Finalize results
        await finalizeAndDisplayResults(query, concepts);
        
      } catch (error) {
        handleSearchError(error);
      } finally {
        toggleUI(false);
      }
    }

    // Verify and highlight MeSH terms
    async function verifyAndHighlightMeshTerms(searchTerms) {
      logMessage("üî¨ Verifying MeSH terms...\n", 'info');
      const meshPattern = /\[([^\]]+)\]/g;
      const uniqueMeshTerms = [...new Set(
        searchTerms.flatMap(term => Array.from(term.matchAll(meshPattern), m => m[1]))
      )];
      
      const invalidTerms = new Set();
      for (const term of uniqueMeshTerms) {
        const isValid = await verifyMeshTerm(term);
        if (!isValid) invalidTerms.add(term);
        await new Promise(resolve => setTimeout(resolve, NCBI_REQUEST_DELAY_MS));
      }
      
      logMessage("Search strategies:\n", 'info');
      searchTerms.forEach((s, i) => {
        let highlighted = s.replace(meshPattern, (match, term) => 
          invalidTerms.has(term) ? `<span class="invalid-mesh">${match}</span>` : match
        );
        logMessage(`  ${i + 1}. ${highlighted}\n`, 'info', true);
      });
    }

    // Execute search strategies
    async function executeSearchStrategies(searchTerms) {
      const perTermCount = Math.ceil(state.config.articlesPerIteration / searchTerms.length) + 5;
      const pmidArrays = [];
      
      for (const [index, term] of searchTerms.entries()) {
        logMessage(`  Executing search ${index + 1}/${searchTerms.length}...`, 'info');
        const pmids = await searchPubMed(term, perTermCount);
        pmidArrays.push(pmids);
        logMessage(` Found ${pmids.length} articles\n`, 'success');
        await new Promise(resolve => setTimeout(resolve, NCBI_REQUEST_DELAY_MS));
      }
      
      return pmidArrays;
    }

    // Process search results
    async function processSearchResults(pmidArrays, iteration) {
      const uniquePmids = [...new Set(pmidArrays.flat())];
      logMessage(`\nüìä Found ${uniquePmids.length} unique articles in iteration ${iteration}\n`, 'info');
      
      const newPmids = uniquePmids.filter(pmid => !state.searchState.allArticles[pmid]);
      const newArticles = [];
      
      if (newPmids.length > 0) {
        logMessage(`  Fetching details for ${newPmids.length} new articles...\n`, 'info');
        const fetchedArticles = await fetchPubMedDetails(newPmids);
        
        fetchedArticles.forEach(article => {
          article.found_in_iteration = iteration;
          state.searchState.allArticles[article.pmid] = article;
          newArticles.push(article);
        });
      }
      
      const currentArticles = uniquePmids
        .map(pmid => state.searchState.allArticles[pmid])
        .filter(Boolean);
      
      return { newArticles, currentArticles };
    }

    // Display iteration summary
    function displayIterationSummary(iteration, topArticles, insights) {
      logMessage(`\nüìà ITERATION ${iteration} SUMMARY:\n`, 'success');
      
      if (topArticles.length > 0) {
        logMessage("\nüèÜ Top articles:\n", 'info');
        topArticles.slice(0, 3).forEach((article, i) => {
          const scoreClass = article.relevance_score >= 80 ? 'good-score' : 
                           article.relevance_score >= 60 ? 'medium-score' : 'poor-score';
          logMessage(`${i + 1}. ${article.title.substring(0, 100)}...\n`, 'info');
          logMessage(`   Score: <span class="${scoreClass}">${article.relevance_score.toFixed(1)}</span> | `, 'info', true);
          logMessage(`Concepts: ${article.concepts_present.join(", ")}\n`, 'concept');
        });
      }
      
      logMessage(`\nüí° Insights:\n${insights.lessons}\n`, 'info');
      logMessage(`\nüéØ Next strategy:\n${insights.nextStrategy}\n`, 'info');
    }

    // Finalize and display comprehensive results
    async function finalizeAndDisplayResults(query, concepts) {
      const allArticles = Object.values(state.searchState.allArticles);
      
      if (allArticles.length === 0) {
        logMessage("\n‚ö†Ô∏è No articles found in the search.\n", 'warning');
        return;
      }
      
      logMessage(`\n\nüéØ FINALIZING RESULTS\n${"=" * 50}\n`, 'success');
      logMessage(`Total unique articles found: ${allArticles.length}\n`, 'info');
      
      // Final ranking with concept coverage
      const articleSummary = allArticles.map((a, i) => ({
        number: i + 1,
        pmid: a.pmid,
        title: a.title,
        relevance_score: a.relevance_score,
        concepts_present: a.concepts_present || [],
        found_in_iteration: a.found_in_iteration
      }));
      
      const prompt = PromptTemplates.FINAL_RANKING_ENHANCED
        .replace("{query}", query)
        .replace("{articles}", JSON.stringify(articleSummary, null, 2))
        .replace("{count}", allArticles.length);
      
      try {
        const responseText = await callOpenAI(prompt, 0.2, 1000);
        const rankingIndices = JSON.parse(responseText);
        
        state.searchState.finalRanking = rankingIndices
          .map(idx => allArticles[idx - 1])
          .filter(Boolean);
        
      } catch (e) {
        logMessage(`AI ranking failed, using score-based ranking: ${e.message}\n`, 'warning');
        state.searchState.finalRanking = [...allArticles]
          .sort((a, b) => b.relevance_score - a.relevance_score);
      }
      
      // Display results across tabs
      displayTopArticles();
      displayEvolutionAnalysis(concepts);
      displayFinalRankings();
      
      // Generate search summary
      await generateSearchSummary(query, concepts);
      
      logMessage("\n‚úÖ Search completed successfully!\n", 'success');
      document.getElementById("progress-status").textContent = "‚úÖ Enhanced search completed!";
    }

    // Display top articles with full details
    function displayTopArticles() {
      const resultsDiv = document.getElementById("results");
      const topArticles = state.searchState.finalRanking.slice(0, 5);
      
      let html = '<h3>Top 5 Articles with Abstracts</h3>\n';
      
      topArticles.forEach((article, i) => {
        const scoreClass = article.relevance_score >= 80 ? 'good-score' : 
                         article.relevance_score >= 60 ? 'medium-score' : 'poor-score';
        
        html += `<div class="article-result">`;
        html += `<h4>#${i + 1}: ${escapeHtml(article.title)}</h4>`;
        html += `<div class="article-metadata">`;
        html += `<strong>Authors:</strong> ${article.authors.slice(0, 3).join(", ")}`;
        if (article.authors.length > 3) html += ` + ${article.authors.length - 3} more`;
        html += `<br><strong>Journal:</strong> ${escapeHtml(article.journal)} (${article.pub_date})`;
        html += `<br><strong>PMID:</strong> ${article.pmid} | `;
        html += `<strong>Score:</strong> <span class="${scoreClass}">${article.relevance_score.toFixed(1)}/100</span>`;
        html += `<br><strong>URL:</strong> <a href="https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/" target="_blank">View on PubMed</a>`;
        html += `<br><strong>Found in iteration:</strong> ${article.found_in_iteration}`;
        
        if (article.concepts_present?.length > 0) {
          html += `<br><strong>Key concepts present:</strong> `;
          article.concepts_present.forEach(concept => {
            html += `<span class="concept-tag">${concept}</span>`;
          });
        }
        
        html += `<br><strong>AI Assessment:</strong> ${escapeHtml(article.ai_reasoning)}`;
        
        if (article.unique_insights) {
          html += `<br><strong>Unique insights:</strong> ${escapeHtml(article.unique_insights)}`;
        }
        
        html += `</div>`;
        html += `<div class="article-abstract">`;
        html += `<strong>Abstract:</strong><br>${escapeHtml(article.abstract || "Not available")}`;
        html += `</div>`;
        html += `</div>`;
      });
      
      resultsDiv.innerHTML = html;
    }

    // Display evolution analysis
    function displayEvolutionAnalysis(concepts) {
      const evolutionDiv = document.getElementById("evolution");
      const conceptEvolutionDiv = document.getElementById("concept-evolution");
      
      // Search evolution overview
      let evolutionText = `SEARCH EVOLUTION OVERVIEW\n${"=" * 50}\n\n`;
      evolutionText += `Total iterations: ${state.searchState.iterationsData.length}\n`;
      evolutionText += `Total unique articles: ${Object.keys(state.searchState.allArticles).length}\n`;
      evolutionText += `Final ranking size: ${state.searchState.finalRanking.length}\n\n`;
      
      state.searchState.iterationsData.forEach(iter => {
        evolutionText += `Iteration ${iter.number}:\n`;
        evolutionText += `  ‚Ä¢ Strategies used: ${iter.searchTerms.length}\n`;
        evolutionText += `  ‚Ä¢ Articles found: ${iter.uniqueArticles} (${iter.newArticles} new)\n`;
        evolutionText += `  ‚Ä¢ Best score: ${iter.topArticles[0]?.relevance_score.toFixed(1) || 'N/A'}\n`;
        evolutionText += `  ‚Ä¢ Key lesson: ${iter.lessons.substring(0, 100)}...\n\n`;
      });
      
      evolutionDiv.textContent = evolutionText;
      
      // Concept evolution analysis
      let conceptText = `CONCEPT EVOLUTION ANALYSIS\n${"=" * 50}\n\n`;
      
      const sortedConcepts = Object.entries(state.searchState.conceptEvolution)
        .sort((a, b) => b[1].avgScore - a[1].avgScore);
      
      conceptText += "Most effective concepts (by average relevance score):\n\n";
      sortedConcepts.forEach(([concept, data]) => {
        conceptText += `‚Ä¢ ${concept}:\n`;
        conceptText += `  - Frequency: ${data.frequency} articles\n`;
        conceptText += `  - Avg Score: ${data.avgScore.toFixed(1)}/100\n`;
        conceptText += `  - Articles: ${data.articles.slice(0, 5).join(", ")}${data.articles.length > 5 ? "..." : ""}\n\n`;
      });
      
      // Identify missing concepts
      const allConcepts = [
        ...concepts.primary_concepts,
        ...concepts.secondary_concepts,
        ...concepts.methodological_terms
      ];
      
      const missingConcepts = allConcepts.filter(c => 
        !state.searchState.conceptEvolution[c] || 
        state.searchState.conceptEvolution[c].frequency < 2
      );
      
      if (missingConcepts.length > 0) {
        conceptText += "\n‚ö†Ô∏è Underrepresented concepts:\n";
        missingConcepts.forEach(c => {
          conceptText += `  - ${c}\n`;
        });
      }
      
      conceptEvolutionDiv.textContent = conceptText;
    }

    // Display final rankings
    function displayFinalRankings() {
      const rankingsDiv = document.getElementById("rankings");
      
      let rankingsText = `COMPLETE ARTICLE RANKINGS\n${"=" * 50}\n\n`;
      rankingsText += `Total articles ranked: ${state.searchState.finalRanking.length}\n\n`;
      
      state.searchState.finalRanking.forEach((article, i) => {
        const scoreClass = article.relevance_score >= 80 ? 'üü¢' : 
                         article.relevance_score >= 60 ? 'üü°' : 'üî¥';
        
        rankingsText += `${i + 1}. ${scoreClass} ${article.title}\n`;
        rankingsText += `   Journal: ${article.journal} (${article.pub_date})\n`;
        rankingsText += `   PMID: ${article.pmid} | Score: ${article.relevance_score.toFixed(1)}\n`;
        rankingsText += `   Iteration: ${article.found_in_iteration} | `;
        rankingsText += `Concepts: ${(article.concepts_present || []).join(", ")}\n`;
        rankingsText += `   URL: https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n\n`;
      });
      
      rankingsDiv.textContent = rankingsText;
    }

    // Generate comprehensive search summary
    async function generateSearchSummary(query, concepts) {
      logMessage("\nüìù Generating comprehensive search summary...\n", 'info');
      
      const evolutionData = {
        query,
        total_iterations: state.searchState.iterationsData.length,
        total_articles: Object.keys(state.searchState.allArticles).length,
        concept_coverage: state.searchState.conceptEvolution,
        iteration_summaries: state.searchState.iterationsData.map(iter => ({
          number: iter.number,
          strategies: iter.searchTerms.length,
          articles: iter.uniqueArticles,
          best_score: iter.topArticles[0]?.relevance_score || 0,
          key_finding: iter.topArticles[0]?.title || "None"
        }))
      };
      
      const prompt = PromptTemplates.SEARCH_SUMMARY_ENHANCED
        .replace("{query}", query)
        .replace("{concepts}", JSON.stringify(concepts))
        .replace("{evolution_data}", JSON.stringify(evolutionData, null, 2));
      
      try {
        const summary = await callOpenAI(prompt, 0.3, 800);
        
        const evolutionDiv = document.getElementById("evolution");
        evolutionDiv.textContent += `\n\nEXECUTIVE SUMMARY\n${"=" * 50}\n\n${summary}`;
        
      } catch (e) {
        logMessage(`Summary generation failed: ${e.message}`, 'error');
      }
    }

    // Generate abstract summary
    async function generateAbstractSummary() {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results available to summarize.");
        return;
      }
      
      const count = parseInt(document.getElementById("summary-count").value, 10) || 5;
      const topN = state.searchState.finalRanking.slice(0, count);
      
      const summaryDiv = document.getElementById("summary");
      summaryDiv.textContent = "Generating AI summary... Please wait.";
      
      let abstractsText = "";
      topN.forEach((article, i) => {
        abstractsText += `\n${i + 1}. ${article.title}\n`;
        abstractsText += `   Authors: ${article.authors.slice(0, 3).join(", ")}`;
        if (article.authors.length > 3) abstractsText += ` et al.`;
        abstractsText += `\n   Journal: ${article.journal} (${article.pub_date})\n`;
        abstractsText += `   PMID: ${article.pmid}\n`;
        abstractsText += `   Relevance Score: ${article.relevance_score.toFixed(1)}\n`;
        abstractsText += `   Abstract: ${article.abstract || "Not available"}\n`;
        abstractsText += "\n" + "-".repeat(80) + "\n";
      });
      
      const summaryPrompt = PromptTemplates.ABSTRACT_SUMMARY
        .replace("{abstracts}", abstractsText);
      
      try {
        const summaryResponse = await callOpenAI(summaryPrompt, 0.3, 1200);
        summaryDiv.textContent = `AI SUMMARY OF TOP ${count} ARTICLES\n`;
        summaryDiv.textContent += "=".repeat(50) + "\n\n";
        summaryDiv.textContent += summaryResponse;
      } catch (e) {
        summaryDiv.textContent = `‚ùå Error generating summary: ${e.message}`;
      }
    }

    // Handle search errors
    function handleSearchError(error) {
      if (error.name === 'AbortError' || error.message === 'Search cancelled') {
        document.getElementById("progress-status").textContent = "‚ùå Search cancelled.";
        logMessage("\n\nSearch cancelled by user.\n", 'warning');
      } else {
        document.getElementById("progress-status").textContent = "‚ùå An error occurred.";
        logMessage(`\n\nSearch error: ${error.message}\n`, 'error');
      }
    }

    // Clear all display areas
    function clearAllDisplays() {
      ['iteration-log', 'results', 'summary', 'evolution', 'concept-evolution', 'rankings'].forEach(id => {
        document.getElementById(id).textContent = '';
      });
      document.getElementById('concept-display').style.display = 'none';
    }

    // Reset search state
    function resetSearchState() {
      state.searchState = {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        totalInputTokens: 0,
        totalOutputTokens: 0,
        keyConcepts: null,
        conceptEvolution: {},
        searchHistory: []
      };
      tokenCounter.reset();
      updateTokenDisplay();
    }

    // Toggle UI during search
    function toggleUI(isSearching) {
      document.getElementById("start-btn").disabled = isSearching;
      document.getElementById("start-btn").style.display = isSearching ? 'none' : 'inline-block';
      document.getElementById("cancel-btn").style.display = isSearching ? 'inline-block' : 'none';
      
      if (isSearching) {
        document.getElementById("progress-status").innerHTML = 'Searching... <span class="spinner"></span>';
      }
      
      const inputs = document.querySelectorAll('#config-section input, #config-section select, #query-section input, #query-section select');
      inputs.forEach(el => {
        if (el.id !== 'test-api-btn') {
          el.disabled = isSearching;
        }
      });
    }

    // Export results
    function exportResults(format) {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results to export.");
        return;
      }
      
      let content = '';
      let filename = `pubmed_results_${new Date().toISOString().split('T')[0]}`;
      let mimeType = 'text/plain';
      
      if (format === 'json') {
        content = JSON.stringify({
          query: document.getElementById("query-input").value,
          date: new Date().toISOString(),
          totalArticles: state.searchState.finalRanking.length,
          iterations: state.searchState.iterationsData.length,
          concepts: state.searchState.keyConcepts,
          articles: state.searchState.finalRanking,
          tokenUsage: {
            input: tokenCounter.inputTokens,
            output: tokenCounter.outputTokens,
            estimatedCost: tokenCounter.getCostEstimate(state.config.modelChoice)
          }
        }, null, 2);
        filename += '.json';
        mimeType = 'application/json';
      } else if (format === 'csv') {
        // CSV header
        content = 'Rank,PMID,Title,Authors,Journal,Year,Score,Concepts Present,URL\n';
        state.searchState.finalRanking.forEach((article, i) => {
          content += `${i + 1},`;
          content += `"${article.pmid}",`;
          content += `"${article.title.replace(/"/g, '""')}",`;
          content += `"${article.authors.slice(0, 3).join('; ')}",`;
          content += `"${article.journal.replace(/"/g, '""')}",`;
          content += `${article.pub_date},`;
          content += `${article.relevance_score.toFixed(1)},`;
          content += `"${(article.concepts_present || []).join('; ')}",`;
          content += `https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n`;
        });
        filename += '.csv';
        mimeType = 'text/csv';
      } else {
        // Text format
        content = `ENHANCED AI-POWERED PUBMED SEARCH RESULTS\n`;
        content += `${"=" * 60}\n\n`;
        content += `Query: ${document.getElementById("query-input").value}\n`;
        content += `Date: ${new Date().toLocaleString()}\n`;
        content += `Model: ${state.config.modelChoice}\n`;
        content += `Total Articles: ${state.searchState.finalRanking.length}\n`;
        content += `Iterations: ${state.searchState.iterationsData.length}\n`;
        content += `Token Usage: Input: ${tokenCounter.inputTokens}, Output: ${tokenCounter.outputTokens}\n`;
        content += `Estimated Cost: $${tokenCounter.getCostEstimate(state.config.modelChoice).toFixed(4)}\n\n`;
        
        content += `KEY CONCEPTS IDENTIFIED:\n`;
        if (state.searchState.keyConcepts) {
          content += `Primary: ${state.searchState.keyConcepts.primary_concepts.join(", ")}\n`;
          content += `Secondary: ${state.searchState.keyConcepts.secondary_concepts.join(", ")}\n\n`;
        }
        
        content += `SEARCH EVOLUTION:\n`;
        content += document.getElementById("evolution").textContent + "\n\n";
        
        content += `TOP ARTICLES:\n`;
        content += document.getElementById("results").textContent + "\n\n";
        
        if (document.getElementById("summary").textContent) {
          content += `AI SUMMARY:\n`;
          content += document.getElementById("summary").textContent + "\n\n";
        }
        
        content += `COMPLETE RANKINGS:\n`;
        content += document.getElementById("rankings").textContent;
        
        filename += '.txt';
      }
      
      // Download file
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Validate API key
    function validateAPIKey(key) {
      if (!key || key.trim().length === 0) {
        return { valid: false, message: "API key is empty" };
      }
      
      // OpenAI API keys can have various prefixes
      const validPrefixes = ['sk-', 'sk-proj-'];
      const hasValidPrefix = validPrefixes.some(prefix => key.startsWith(prefix));
      
      if (!hasValidPrefix && !key.includes('-')) {
        return { valid: false, message: "API key format appears invalid" };
      }
      
      return { valid: true, message: "API key format looks valid" };
    }

    // Test API key
    async function testAPIKey() {
      const apiKey = document.getElementById("api-key").value.trim();
      const resultDiv = document.getElementById("api-test-result");
      
      const validation = validateAPIKey(apiKey);
      if (!validation.valid) {
        resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå ${validation.message}</div>`;
        return;
      }
      
      resultDiv.innerHTML = '<div class="api-test-result">Testing API key...</div>';
      
      try {
        const response = await fetch("https://api.openai.com/v1/models", {
          method: "GET",
          headers: {
            "Authorization": `Bearer ${apiKey}`
          }
        });
        
        if (response.ok) {
          resultDiv.innerHTML = '<div class="api-test-result api-test-success">‚úÖ API key is valid and working!</div>';
        } else {
          const errorData = await response.json().catch(() => ({ error: { message: "Unknown error" } }));
          resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå API key invalid: ${errorData.error?.message || response.statusText}</div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå Connection error: ${error.message}</div>`;
      }
    }

    // HTML escape function
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ========== Event Listeners ==========
    
    // Test API button
    document.getElementById("test-api-btn").addEventListener("click", testAPIKey);
    
    // Start search button
    document.getElementById("start-btn").addEventListener("click", () => {
      // Gather configuration
      state.config = {
        openAIKey: document.getElementById("api-key").value.trim(),
        modelChoice: document.getElementById("model-select").value,
        totalIterations: parseInt(document.getElementById("iterations").value, 10),
        articlesPerIteration: parseInt(document.getElementById("articles-per-iter").value, 10),
        topArticlesPerIteration: parseInt(document.getElementById("top-articles").value, 10),
        explorationFactor: document.getElementById("exploration-factor").value
      };
      
      const query = document.getElementById("query-input").value.trim();
      
      // Validate
      const validation = validateAPIKey(state.config.openAIKey);
      if (!validation.valid) {
        alert(`Invalid API key: ${validation.message}\n\nPlease enter a valid OpenAI API key.`);
        return;
      }
      
      if (!query) {
        alert("Please enter a research query.");
        return;
      }
      
      // Start enhanced search
      runEnhancedIterativeSearch(query);
    });
    
    // Cancel button
    document.getElementById("cancel-btn").addEventListener("click", () => {
      if (state.abortController) {
        state.abortController.abort();
        logMessage("\n\nüõë User cancelled the search.\n", 'warning');
      }
    });
    
    // Summary button
    document.getElementById("summary-btn").addEventListener("click", generateAbstractSummary);
    
    // Initialize on page load
    window.addEventListener('load', () => {
      // Focus on query input
      document.getElementById("query-input").focus();
      
      // Show CORS warning if local
      if (isRunningLocally) {
        document.getElementById('cors-warning').style.display = 'block';
      }
      
      // Set up enter key handler for query input
      document.getElementById("query-input").addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !document.getElementById("start-btn").disabled) {
          document.getElementById("start-btn").click();
        }
      });
    });
  </script>
</body>
</html>
