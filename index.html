<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smart PubMed Search - MeSH Learning Edition</title>
  <style>
    /* Clean, focused styling */
    * {
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      color: #1a5490;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2em;
    }
    
    h2, h3 { 
      color: #2E5AAC;
      margin-top: 20px;
    }
    
    /* Form elements */
    label { 
      font-weight: 600;
      display: inline-block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #495057;
    }
    
    input, select, button { 
      margin: 5px 0;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 14px;
    }
    
    button {
      cursor: pointer;
      background-color: #228be6;
      color: white;
      border: none;
      font-weight: 600;
    }
    
    button:hover:not(:disabled) {
      background-color: #1971c2;
    }
    
    button:disabled { 
      background-color: #e9ecef;
      color: #868e96;
      cursor: not-allowed;
    }
    
    /* Section styling */
    .section { 
      background: white;
      border: 1px solid #dee2e6;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Output areas */
    .output-area {
      width: 100%;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      background: #f8f9fa;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      line-height: 1.5;
    }
    
    #search-log {
      max-height: 600px;
    }
    
    /* MeSH term display */
    .mesh-term {
      display: inline-block;
      background: #e3f2fd;
      border: 1px solid #64b5f6;
      color: #1565c0;
      padding: 4px 8px;
      margin: 2px;
      border-radius: 3px;
      font-size: 13px;
    }
    
    .mesh-term-count {
      background: #1976d2;
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      margin-left: 5px;
      font-size: 11px;
    }
    
    /* Search display */
    .search-item {
      background: #f1f3f5;
      padding: 8px;
      margin: 5px 0;
      border-left: 4px solid #339af0;
      font-family: monospace;
      font-size: 12px;
    }
    
    .search-success {
      border-left-color: #2b8a3e;
      background: #d3f9d8;
    }
    
    .search-failed {
      border-left-color: #c92a2a;
      background: #ffe0e0;
    }
    
    /* Concept display */
    .concept-group {
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    
    .concept-group h4 {
      margin: 0 0 8px 0;
      color: #495057;
      font-size: 14px;
    }
    
    /* Strategy display */
    .strategy-box {
      background: #e7f5ff;
      border: 1px solid #74c0fc;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
    }
    
    /* Results */
    .article-result {
      background: #f8f9fa;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .article-result h4 {
      margin: 0 0 10px 0;
      color: #1a5490;
    }
    
    .score-high {
      color: #2b8a3e;
      font-weight: bold;
    }
    
    .score-medium {
      color: #e67700;
      font-weight: bold;
    }
    
    .score-low {
      color: #c92a2a;
      font-weight: bold;
    }
    
    /* Important info */
    .info-box {
      background: #e7f5ff;
      border: 1px solid #74c0fc;
      border-radius: 5px;
      padding: 12px;
      margin: 10px 0;
    }
    
    .warning-box {
      background: #fff3cd;
      border: 1px solid #ffec99;
      border-radius: 5px;
      padding: 12px;
      margin: 10px 0;
      color: #856404;
    }
    
    /* Primary button */
    .primary-button {
      background-color: #228be6;
      font-size: 16px;
      padding: 12px 24px;
      margin: 10px 0;
    }
    
    .secondary-button {
      background-color: #495057;
      font-size: 14px;
      padding: 8px 16px;
    }
  </style>
</head>
<body>
  <h1>üî¨ Smart PubMed Search - MeSH Learning Edition</h1>
  
  <!-- Configuration Section -->
  <div class="section">
    <h2>Configuration</h2>
    
    <label for="api-key">OpenAI API Key:</label>
    <input type="password" id="api-key" placeholder="sk-..." size="50" />
    
    <label for="model-select" style="margin-left: 20px;">Model:</label>
    <select id="model-select">
      <option value="gpt-4-turbo" selected>GPT-4 Turbo</option>
      <option value="gpt-4o-mini">GPT-4o Mini (Cheaper)</option>
      <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Cheapest)</option>
    </select>
  </div>

  <!-- Query Section -->
  <div class="section">
    <h2>Research Query</h2>
    
    <input type="text" id="query-input" placeholder="e.g. 'CAR-T therapy for lymphoma clinical outcomes'" 
           style="width: 100%; font-size: 16px; padding: 10px;" />
    
    <div style="margin-top: 15px;">
      <label for="iterations">Iterations:</label>
      <input type="number" id="iterations" value="4" min="2" max="6" style="width:50px;" />
      
      <label for="articles-per-search" style="margin-left: 20px;">Articles per search:</label>
      <input type="number" id="articles-per-search" value="20" min="10" max="30" style="width:50px;" />
      
      <button id="start-btn" class="primary-button" style="margin-left: 30px;">
        üîç Start Smart Search
      </button>
      <button id="cancel-btn" class="primary-button" style="display:none; background-color: #c92a2a;">
        ‚ùå Cancel
      </button>
    </div>
    
    <div class="info-box" style="margin-top: 15px;">
      <strong>üí° How it works:</strong> Starts with broad two-concept searches, learns MeSH terms from successful results, 
      then uses those MeSH terms to find more relevant articles. Simple but powerful!
    </div>
  </div>

  <!-- Search Progress -->
  <div class="section">
    <h2>Search Progress</h2>
    <div id="search-log" class="output-area"></div>
  </div>

  <!-- MeSH Learning Display -->
  <div class="section" id="mesh-section" style="display:none;">
    <h2>üè∑Ô∏è Discovered MeSH Terms</h2>
    <div id="mesh-display"></div>
  </div>

  <!-- Results Section -->
  <div class="section" id="results-section" style="display:none;">
    <h2>üìä Results</h2>
    
    <h3>Top Articles</h3>
    <div id="top-articles"></div>
    
    <h3>Summary</h3>
    <button id="summarize-btn" class="secondary-button">Generate Summary of Top 5 Articles</button>
    <div id="summary" class="output-area" style="display:none; margin-top: 10px;"></div>
    
    <h3>All Articles</h3>
    <div id="all-articles" class="output-area"></div>
  </div>

  <script>
    // ========== State Management ==========
    let state = {
      query: '',
      apiKey: '',
      model: 'gpt-4-turbo',
      isSearching: false,
      abortController: null,
      articles: {},  // PMID -> article
      meshTerms: {}, // term -> count
      searchHistory: [],
      iterations: []
    };

    // ========== Core Functions ==========
    
    function log(message, isHtml = false) {
      const logArea = document.getElementById('search-log');
      const timestamp = new Date().toLocaleTimeString();
      
      if (isHtml) {
        const div = document.createElement('div');
        div.innerHTML = `[${timestamp}] ${message}`;
        logArea.appendChild(div);
      } else {
        logArea.textContent += `[${timestamp}] ${message}`;
      }
      logArea.scrollTop = logArea.scrollHeight;
    }

    async function callOpenAI(prompt, temperature = 0.3) {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${state.apiKey}`
        },
        body: JSON.stringify({
          model: state.model,
          messages: [{ role: 'user', content: prompt }],
          temperature: temperature,
          max_tokens: 800
        }),
        signal: state.abortController?.signal
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || 'API error');
      }

      const data = await response.json();
      return data.choices[0].message.content.trim();
    }

    // Extract concepts from query (simplified)
    async function extractConcepts(query) {
      log('\nüß† Analyzing query concepts...\n');
      
      const prompt = `Extract key medical concepts from this query: "${query}"

Identify:
1. INTERVENTION/THERAPY: treatments, procedures, drugs
2. CONDITION/DISEASE: medical conditions, diseases
3. POPULATION: patient characteristics, age groups
4. OUTCOME: what's being measured or studied
5. STUDY TYPE: trial phase, study design

Return ONLY a JSON object like:
{
  "therapy": ["CAR-T", "chimeric antigen receptor"],
  "disease": ["lymphoma", "B-cell lymphoma"],
  "population": ["adults", "refractory patients"],
  "outcome": ["survival", "response rate"],
  "study": ["clinical trial", "phase 2"]
}

Include 1-3 terms per category. Some categories may be empty.`;

      try {
        const response = await callOpenAI(prompt);
        const concepts = JSON.parse(response);
        
        // Display concepts
        log('<div class="concept-group">', true);
        Object.entries(concepts).forEach(([type, terms]) => {
          if (terms && terms.length > 0) {
            log(`<h4>${type.toUpperCase()}:</h4>`, true);
            terms.forEach(term => {
              log(`<span class="mesh-term">${term}</span>`, true);
            });
          }
        });
        log('</div>', true);
        
        return concepts;
      } catch (e) {
        log(`‚ö†Ô∏è Concept extraction failed: ${e.message}\n`);
        // Fallback
        return {
          therapy: [query.split(' ')[0]],
          disease: [query.split(' ').slice(-1)[0]]
        };
      }
    }

    // Generate two-concept searches
    function generateTwoConceptSearches(concepts) {
      const searches = [];
      
      // Helper to create search with OR
      const makeSearch = (terms1, terms2) => {
        if (!terms1?.length || !terms2?.length) return null;
        
        const part1 = terms1.length > 1 
          ? `(${terms1.map(t => `"${t}"`).join(' OR ')})` 
          : `"${terms1[0]}"`;
        const part2 = terms2.length > 1
          ? `(${terms2.map(t => `"${t}"`).join(' OR ')})`
          : `"${terms2[0]}"`;
        
        return `${part1} AND ${part2}`;
      };
      
      // Generate combinations
      if (concepts.therapy && concepts.disease) {
        searches.push(makeSearch(concepts.therapy, concepts.disease));
      }
      if (concepts.therapy && concepts.outcome) {
        searches.push(makeSearch(concepts.therapy, concepts.outcome));
      }
      if (concepts.disease && concepts.outcome) {
        searches.push(makeSearch(concepts.disease, concepts.outcome));
      }
      if (concepts.therapy && concepts.study) {
        searches.push(makeSearch(concepts.therapy, concepts.study));
      }
      if (concepts.disease && concepts.study) {
        searches.push(makeSearch(concepts.disease, concepts.study));
      }
      
      // Add some single concept searches if we have few combinations
      if (searches.length < 3) {
        if (concepts.therapy?.length > 0) {
          searches.push(`"${concepts.therapy[0]}"`);
        }
        if (concepts.disease?.length > 0) {
          searches.push(`"${concepts.disease[0]}"`);
        }
      }
      
      return searches.filter(s => s !== null);
    }

    // Generate MeSH-based searches
    function generateMeshSearches(meshTerms) {
      const searches = [];
      
      // Sort by frequency
      const sortedTerms = Object.entries(meshTerms)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([term]) => term);
      
      // Create pairs of top MeSH terms
      for (let i = 0; i < sortedTerms.length - 1 && searches.length < 4; i++) {
        for (let j = i + 1; j < sortedTerms.length && searches.length < 4; j++) {
          searches.push(`"${sortedTerms[i]}"[MeSH] AND "${sortedTerms[j]}"[MeSH]`);
        }
      }
      
      // Add single high-frequency MeSH terms with text words
      if (searches.length < 4 && sortedTerms.length > 0) {
        searches.push(`"${sortedTerms[0]}"[MeSH]`);
      }
      
      return searches;
    }

    // Search PubMed
    async function searchPubMed(searchTerm, maxResults = 20) {
      const url = 'https://corsproxy.io/?' + encodeURIComponent(
        `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(searchTerm)}&retmode=xml&retmax=${maxResults}&sort=relevance`
      );
      
      const response = await fetch(url, { signal: state.abortController?.signal });
      const text = await response.text();
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/xml');
      
      const ids = Array.from(doc.getElementsByTagName('Id')).map(el => el.textContent);
      return ids;
    }

    // Fetch article details
    async function fetchArticleDetails(pmids) {
      if (pmids.length === 0) return [];
      
      const url = 'https://corsproxy.io/?' + encodeURIComponent(
        `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${pmids.join(',')}&retmode=xml`
      );
      
      const response = await fetch(url, { signal: state.abortController?.signal });
      const text = await response.text();
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/xml');
      
      const articles = [];
      const articleNodes = doc.getElementsByTagName('PubmedArticle');
      
      for (const node of articleNodes) {
        const pmid = node.querySelector('PMID')?.textContent || '';
        const title = node.querySelector('ArticleTitle')?.textContent || '';
        const journal = node.querySelector('Title')?.textContent || '';
        const year = node.querySelector('PubDate Year')?.textContent || 
                     node.querySelector('MedlineDate')?.textContent?.substring(0, 4) || '';
        
        // Get abstract
        const abstractTexts = Array.from(node.querySelectorAll('AbstractText'));
        const abstract = abstractTexts.map(n => n.textContent).join(' ');
        
        // Get MeSH terms - this is crucial!
        const meshTerms = Array.from(node.querySelectorAll('MeshHeading DescriptorName'))
          .map(n => n.textContent);
        
        articles.push({
          pmid,
          title,
          journal,
          year,
          abstract,
          meshTerms,
          score: 0,
          reasoning: ''
        });
      }
      
      return articles;
    }

    // Score articles with AI
    async function scoreArticles(articles, query) {
      if (articles.length === 0) return [];
      
      log('ü§ñ Scoring articles for relevance...\n');
      
      const prompt = `Score these articles for relevance to: "${query}"

For each article, provide a score (0-100) and brief reasoning.

Articles:
${articles.map((a, i) => `
${i + 1}. ${a.title}
   Journal: ${a.journal} (${a.year})
   Abstract: ${a.abstract.substring(0, 300)}...
`).join('\n')}

Return a JSON array: [{"index": 1, "score": 85, "reasoning": "..."}, ...]`;

      try {
        const response = await callOpenAI(prompt);
        const scores = JSON.parse(response);
        
        scores.forEach(s => {
          if (articles[s.index - 1]) {
            articles[s.index - 1].score = s.score;
            articles[s.index - 1].reasoning = s.reasoning;
          }
        });
      } catch (e) {
        log(`‚ö†Ô∏è Scoring failed: ${e.message}\n`);
        articles.forEach(a => a.score = 50);
      }
      
      return articles;
    }

    // Learn MeSH terms from high-scoring articles
    function learnMeshTerms(articles, threshold = 70) {
      const goodArticles = articles.filter(a => a.score >= threshold);
      
      goodArticles.forEach(article => {
        article.meshTerms.forEach(term => {
          state.meshTerms[term] = (state.meshTerms[term] || 0) + 1;
        });
      });
      
      // Display discovered MeSH terms
      if (Object.keys(state.meshTerms).length > 0) {
        displayMeshTerms();
      }
    }

    // Display MeSH terms
    function displayMeshTerms() {
      const meshSection = document.getElementById('mesh-section');
      const meshDisplay = document.getElementById('mesh-display');
      
      meshSection.style.display = 'block';
      
      const sortedTerms = Object.entries(state.meshTerms)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20);
      
      meshDisplay.innerHTML = sortedTerms
        .map(([term, count]) => 
          `<span class="mesh-term">${term}<span class="mesh-term-count">${count}</span></span>`
        )
        .join('');
    }

    // Main search function
    async function performSearch() {
      state.query = document.getElementById('query-input').value.trim();
      state.apiKey = document.getElementById('api-key').value.trim();
      state.model = document.getElementById('model-select').value;
      
      if (!state.query || !state.apiKey) {
        alert('Please enter both a query and API key');
        return;
      }
      
      // Reset state
      state.articles = {};
      state.meshTerms = {};
      state.searchHistory = [];
      state.iterations = [];
      state.abortController = new AbortController();
      
      // Clear displays
      document.getElementById('search-log').innerHTML = '';
      document.getElementById('mesh-section').style.display = 'none';
      document.getElementById('results-section').style.display = 'none';
      
      // UI state
      document.getElementById('start-btn').style.display = 'none';
      document.getElementById('cancel-btn').style.display = 'inline-block';
      state.isSearching = true;
      
      try {
        log(`üöÄ Starting smart search for: "${state.query}"\n`);
        log(`${'='.repeat(60)}\n\n`);
        
        // Extract concepts
        const concepts = await extractConcepts(state.query);
        
        const maxIterations = parseInt(document.getElementById('iterations').value);
        const articlesPerSearch = parseInt(document.getElementById('articles-per-search').value);
        
        for (let iter = 1; iter <= maxIterations; iter++) {
          if (state.abortController.signal.aborted) break;
          
          log(`\nüîÑ ITERATION ${iter}/${maxIterations}\n`);
          log(`${'='.repeat(40)}\n`);
          
          let searches = [];
          
          if (iter === 1) {
            // First iteration: two-concept searches
            log('üìã Strategy: Two-concept broad searches\n\n');
            searches = generateTwoConceptSearches(concepts);
          } else if (Object.keys(state.meshTerms).length >= 4) {
            // Later iterations: use discovered MeSH terms
            log('üìã Strategy: MeSH-based searches from learned terms\n\n');
            searches = generateMeshSearches(state.meshTerms);
            
            // Also add a refined two-concept search
            const refinedSearch = generateTwoConceptSearches(concepts).slice(0, 1);
            searches.push(...refinedSearch);
          } else {
            // Fallback: continue with two-concept searches
            log('üìã Strategy: Continuing with two-concept searches\n\n');
            searches = generateTwoConceptSearches(concepts);
          }
          
          // Execute searches
          const iterationPmids = [];
          
          for (const search of searches) {
            log(`<div class="search-item">üîç ${search}</div>`, true);
            
            try {
              const pmids = await searchPubMed(search, articlesPerSearch);
              
              if (pmids.length > 0) {
                log(`<div class="search-success">‚úÖ Found ${pmids.length} articles</div>`, true);
                iterationPmids.push(...pmids);
                state.searchHistory.push({ search, success: true, count: pmids.length });
              } else {
                log(`<div class="search-failed">‚ùå No results</div>`, true);
                state.searchHistory.push({ search, success: false, count: 0 });
              }
              
              // Rate limiting
              await new Promise(resolve => setTimeout(resolve, 400));
              
            } catch (error) {
              log(`<div class="search-failed">‚ùå Error: ${error.message}</div>`, true);
            }
          }
          
          // Process unique PMIDs
          const uniquePmids = [...new Set(iterationPmids)];
          const newPmids = uniquePmids.filter(id => !state.articles[id]);
          
          log(`\nüìä Found ${uniquePmids.length} articles (${newPmids.length} new)\n`);
          
          if (newPmids.length > 0) {
            // Fetch details
            log('üì• Fetching article details...\n');
            const newArticles = await fetchArticleDetails(newPmids);
            
            // Score articles
            const scoredArticles = await scoreArticles(newArticles, state.query);
            
            // Store articles
            scoredArticles.forEach(article => {
              article.iteration = iter;
              state.articles[article.pmid] = article;
            });
            
            // Learn MeSH terms from good articles
            learnMeshTerms(scoredArticles);
            
            // Show top articles from this iteration
            const topArticles = scoredArticles.sort((a, b) => b.score - a.score).slice(0, 3);
            
            if (topArticles.length > 0) {
              log('\nüèÜ Top articles this iteration:\n');
              topArticles.forEach((article, i) => {
                const scoreClass = article.score >= 80 ? 'score-high' : 
                                 article.score >= 60 ? 'score-medium' : 'score-low';
                log(`${i + 1}. ${article.title}\n`);
                log(`   <span class="${scoreClass}">Score: ${article.score}/100</span> - ${article.reasoning}\n`, true);
              });
            }
          }
          
          // Brief pause between iterations
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Display final results
        displayResults();
        
        log(`\n‚úÖ Search complete! Found ${Object.keys(state.articles).length} unique articles.\n`);
        
      } catch (error) {
        if (error.name !== 'AbortError') {
          log(`\n‚ùå Error: ${error.message}\n`);
        }
      } finally {
        state.isSearching = false;
        document.getElementById('start-btn').style.display = 'inline-block';
        document.getElementById('cancel-btn').style.display = 'none';
      }
    }

    // Display results
    function displayResults() {
      const resultsSection = document.getElementById('results-section');
      resultsSection.style.display = 'block';
      
      const allArticles = Object.values(state.articles);
      const sortedArticles = allArticles.sort((a, b) => b.score - a.score);
      
      // Top articles
      const topDiv = document.getElementById('top-articles');
      topDiv.innerHTML = '';
      
      sortedArticles.slice(0, 10).forEach((article, i) => {
        const scoreClass = article.score >= 80 ? 'score-high' : 
                         article.score >= 60 ? 'score-medium' : 'score-low';
        
        const html = `
          <div class="article-result">
            <h4>#${i + 1}: ${article.title}</h4>
            <div>
              <strong>Journal:</strong> ${article.journal} (${article.year}) | 
              <strong>PMID:</strong> ${article.pmid} | 
              <strong class="${scoreClass}">Score: ${article.score}/100</strong> | 
              <strong>Iteration:</strong> ${article.iteration}
            </div>
            <div><strong>URL:</strong> <a href="https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/" target="_blank">View on PubMed</a></div>
            <div><strong>Reasoning:</strong> ${article.reasoning}</div>
            ${article.meshTerms.length > 0 ? `<div><strong>MeSH Terms:</strong> ${article.meshTerms.slice(0, 5).join(', ')}</div>` : ''}
            ${article.abstract ? `<div style="margin-top: 10px;"><strong>Abstract:</strong> ${article.abstract.substring(0, 300)}...</div>` : ''}
          </div>
        `;
        
        topDiv.innerHTML += html;
      });
      
      // All articles summary
      const allDiv = document.getElementById('all-articles');
      allDiv.textContent = `COMPLETE RANKINGS (${sortedArticles.length} articles)\n${'='.repeat(50)}\n\n`;
      
      sortedArticles.forEach((article, i) => {
        allDiv.textContent += `${i + 1}. ${article.title}\n`;
        allDiv.textContent += `   ${article.journal} (${article.year}) | PMID: ${article.pmid} | Score: ${article.score} | Iteration: ${article.iteration}\n\n`;
      });
    }

    // Generate summary
    async function generateSummary() {
      const summaryDiv = document.getElementById('summary');
      summaryDiv.style.display = 'block';
      summaryDiv.textContent = 'Generating summary...';
      
      const topArticles = Object.values(state.articles)
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
      
      const prompt = `Summarize these top research articles related to: "${state.query}"

${topArticles.map((a, i) => `
Article ${i + 1}: ${a.title}
Journal: ${a.journal} (${a.year})
Abstract: ${a.abstract}
`).join('\n---\n')}

Provide:
1. KEY FINDINGS: Main discoveries across the articles
2. METHODS: Common approaches used
3. CLINICAL RELEVANCE: Practical implications
4. GAPS: What's still unknown

Keep it concise but comprehensive.`;

      try {
        const summary = await callOpenAI(prompt, 0.3);
        summaryDiv.textContent = summary;
      } catch (error) {
        summaryDiv.textContent = `Error generating summary: ${error.message}`;
      }
    }

    // Event listeners
    document.getElementById('start-btn').addEventListener('click', performSearch);
    
    document.getElementById('cancel-btn').addEventListener('click', () => {
      if (state.abortController) {
        state.abortController.abort();
        log('\n‚ùå Search cancelled by user.\n');
      }
    });
    
    document.getElementById('summarize-btn').addEventListener('click', generateSummary);
    
    // Enter key support
    document.getElementById('query-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !state.isSearching) {
        performSearch();
      }
    });
  </script>
</body>
</html>
