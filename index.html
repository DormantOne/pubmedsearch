<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced AI-Powered PubMed Research Tool</title>
  <style>
    /* Enhanced styling for professional appearance */
    * {
      box-sizing: border-box;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      color: #1a5490;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.2em;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    
    h2, h3 { 
      color: #2E5AAC;
      margin-top: 20px;
    }
    
    /* Enhanced form styling */
    label { 
      font-weight: 600;
      display: inline-block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #495057;
    }
    
    input, select, button, textarea { 
      margin: 5px 0;
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #4dabf7;
      box-shadow: 0 0 0 3px rgba(77, 171, 247, 0.1);
    }
    
    button {
      cursor: pointer;
      background-color: #228be6;
      color: white;
      border: none;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    button:hover:not(:disabled) {
      background-color: #1971c2;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    button:disabled { 
      background-color: #e9ecef;
      color: #868e96;
      cursor: not-allowed;
      transform: none;
    }
    
    /* Section styling */
    .section { 
      background: white;
      border: 1px solid #dee2e6;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Tab system */
    .tabs {
      display: flex;
      border-bottom: 2px solid #dee2e6;
      margin-bottom: 20px;
      background: white;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }
    
    .tab {
      padding: 12px 24px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-weight: 600;
      color: #495057;
      transition: all 0.3s ease;
      flex: 1;
      text-align: center;
    }
    
    .tab:hover {
      background: #e9ecef;
    }
    
    .tab.active {
      background: white;
      color: #228be6;
      border-bottom: 3px solid #228be6;
      margin-bottom: -2px;
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Status indicators */
    #progress-status { 
      font-style: italic;
      color: #495057;
      margin-top: 10px;
      padding: 10px;
      background: #e7f5ff;
      border-radius: 5px;
      display: inline-block;
    }
    
    /* Output areas */
    .output-area {
      width: 100%;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      background: #f8f9fa;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      line-height: 1.5;
    }
    
    #iteration-log {
      max-height: 500px;
    }
    
    /* Special highlighting */
    .invalid-mesh { 
      background-color: #ffe0e0;
      color: #c92a2a;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #ffa8a8;
    }
    
    .key-concept {
      background-color: #fff3cd;
      color: #856404;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    
    .good-score {
      color: #2b8a3e;
      font-weight: bold;
    }
    
    .medium-score {
      color: #e67700;
      font-weight: bold;
    }
    
    .poor-score {
      color: #c92a2a;
      font-weight: bold;
    }
    
    /* API test result styling */
    .api-test-result {
      margin: 10px 0;
      padding: 12px;
      border-radius: 5px;
      font-weight: 500;
    }
    
    .api-test-success {
      background-color: #d3f9d8;
      color: #2b8a3e;
      border: 1px solid #8ce99a;
    }
    
    .api-test-failure {
      background-color: #ffe0e0;
      color: #c92a2a;
      border: 1px solid #ffa8a8;
    }
    
    /* CORS warning */
    #cors-warning {
      background-color: #fff3cd;
      border: 1px solid #ffec99;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    
    #cors-warning code {
      background-color: #f8f9fa;
      padding: 3px 6px;
      border-radius: 3px;
      font-family: monospace;
      border: 1px solid #dee2e6;
    }
    
    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f3f3;
      border-top: 3px solid #228be6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Token display */
    .token-display {
      background: #e7f5ff;
      padding: 8px 15px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      display: inline-block;
      border: 1px solid #74c0fc;
      margin-left: 20px;
    }
    
    /* Concept tracking */
    .concept-tag {
      display: inline-block;
      background: #e9ecef;
      padding: 4px 10px;
      margin: 2px;
      border-radius: 15px;
      font-size: 12px;
      border: 1px solid #ced4da;
    }
    
    .concept-tag.primary {
      background: #74c0fc;
      color: white;
      border-color: #339af0;
    }
    
    /* Results styling */
    .article-result {
      background: #f8f9fa;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .article-result h4 {
      margin: 0 0 10px 0;
      color: #1a5490;
    }
    
    .article-metadata {
      font-size: 13px;
      color: #6c757d;
      margin: 5px 0;
    }
    
    .article-abstract {
      margin-top: 10px;
      font-style: italic;
      color: #495057;
      line-height: 1.6;
    }
    
    /* Buttons */
    .primary-button {
      background-color: #228be6;
      font-size: 16px;
      padding: 12px 24px;
      margin: 10px 0;
    }
    
    .secondary-button {
      background-color: #495057;
      font-size: 14px;
      padding: 8px 16px;
    }
    
    .success-button {
      background-color: #2b8a3e;
    }
    
    .warning-button {
      background-color: #e67700;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .tabs {
        flex-direction: column;
      }
      
      .tab {
        border-bottom: 1px solid #dee2e6;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üî¨ Enhanced AI-Powered PubMed Research Tool</h1>
    
    <!-- Tab Navigation -->
    <div class="tabs">
      <button class="tab active" onclick="showTab(event, 'search')">üîç Search</button>
      <button class="tab" onclick="showTab(event, 'results')">üìä Results</button>
      <button class="tab" onclick="showTab(event, 'evolution')">üß¨ Evolution</button>
      <button class="tab" onclick="showTab(event, 'config')">‚öôÔ∏è Configuration</button>
    </div>
    
    <!-- Search Tab -->
    <div id="search-tab" class="tab-content active">
      <!-- Configuration Section -->
      <div class="section" id="config-section">
        <h2>Configuration</h2>
        
        <!-- CORS Warning (shown only when running locally) -->
        <div id="cors-warning" style="display:none;">
          <strong>‚ö†Ô∏è Local File Detected - CORS Issues Expected</strong><br>
          <p style="margin:5px 0;">This tool needs to be hosted online to work properly. Quick solutions:</p>
          <ol style="margin:5px 0 5px 20px;">
            <li><strong>GitHub Pages</strong>: Upload to GitHub, enable Pages (free)</li>
            <li><strong>Netlify</strong>: Drag file to <a href="https://netlify.com" target="_blank">netlify.com</a></li>
            <li><strong>Local Server</strong>: Run <code>python -m http.server 8000</code></li>
          </ol>
        </div>
        
        <!-- API Key Input -->
        <label for="api-key">OpenAI API Key:</label><br>
        <input type="password" id="api-key" placeholder="Enter your OpenAI API key" size="50" />
        <button id="test-api-btn" style="margin-left: 10px;">Test API Key</button>
        <div id="api-test-result"></div>
        <p style="font-size: 0.9em; color: #666; margin-top: 5px;">
          * Your API key is used client-side only and is NOT stored.<br>
          * Supports all OpenAI API key formats (sk-, sk-proj-, etc.)
        </p>
        
        <!-- Model Selection -->
        <label for="model-select">AI Model:</label>
        <select id="model-select" style="margin-left: 10px;">
          <option value="gpt-4-turbo">GPT-4 Turbo (Recommended)</option>
          <option value="gpt-4o">GPT-4o</option>
          <option value="gpt-4o-mini">GPT-4o Mini</option>
          <option value="gpt-4">GPT-4</option>
          <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
        </select>
        
        <!-- Token Display -->
        <div class="token-display" id="token-display">
          üî§ Tokens - In: 0 | Out: 0 | Est. Cost: $0.00
        </div>
      </div>

      <!-- Query Section -->
      <div class="section" id="query-section">
        <h2>Research Query</h2>
        <label for="query-input">Enter your medical research question:</label><br>
        <input type="text" id="query-input" size="80" placeholder="e.g. 'Pard3 knockout mice experiments to show polarity of cells in cornea'" 
               style="width: 100%; font-size: 16px; padding: 10px;" />
        
        <!-- Identified Concepts Display -->
        <div id="concept-display" style="margin-top: 15px; display: none;">
          <label>Identified Key Concepts:</label>
          <div id="concept-tags"></div>
        </div>
        
        <h3>Search Parameters</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <div>
            <label for="iterations">Iterations:</label>
            <input type="number" id="iterations" value="4" min="2" max="8" style="width:60px;" />
          </div>
          
          <div>
            <label for="articles-per-iter">Articles per iteration:</label>
            <input type="number" id="articles-per-iter" value="20" min="10" max="50" style="width:60px;" />
          </div>
          
          <div>
            <label for="top-articles">Top articles to analyze:</label>
            <input type="number" id="top-articles" value="8" min="3" max="15" style="width:60px;" />
          </div>
          
          <div>
            <label for="exploration-factor">Exploration factor:</label>
            <select id="exploration-factor">
              <option value="conservative">Conservative (0.2)</option>
              <option value="balanced" selected>Balanced (0.4)</option>
              <option value="explorative">Explorative (0.6)</option>
            </select>
          </div>
        </div>
        
        <button id="start-btn" class="primary-button" style="margin-top: 20px;">
          üîç Start Enhanced Iterative Search
        </button>
        <button id="cancel-btn" class="primary-button warning-button" style="display:none;">
          ‚ùå Cancel Search
        </button>
        <span id="progress-status"></span>
      </div>

      <!-- Progress Log Section -->
      <div class="section" id="log-section">
        <h2>Iteration Progress</h2>
        <div id="iteration-log" class="output-area" aria-live="polite"></div>
      </div>
    </div>
    
    <!-- Results Tab -->
    <div id="results-tab" class="tab-content">
      <div class="section" id="results-section">
        <h2>Top Articles with Abstracts</h2>
        <div id="results" class="output-area"></div>
        
        <h3>AI Summary of Top Articles</h3>
        <div style="margin: 10px 0;">
          <label for="summary-count">Summarize top</label>
          <input type="number" id="summary-count" value="5" min="3" max="15" style="width:50px;" /> articles
          <button id="summary-btn" class="secondary-button" style="margin-left: 10px;">Generate Summary</button>
        </div>
        <div id="summary" class="output-area"></div>
      </div>
    </div>
    
    <!-- Evolution Tab -->
    <div id="evolution-tab" class="tab-content">
      <div class="section" id="evolution-section">
        <h2>Search Evolution Overview</h2>
        <div id="evolution" class="output-area"></div>
        
        <h3>Concept Evolution</h3>
        <div id="concept-evolution" class="output-area"></div>
        
        <h3>Complete Article Rankings</h3>
        <div id="rankings" class="output-area"></div>
      </div>
    </div>
    
    <!-- Configuration Tab -->
    <div id="config-tab" class="tab-content">
      <div class="section">
        <h2>Advanced Configuration</h2>
        <h3>Search Strategy Settings</h3>
        
        <label>
          <input type="checkbox" id="use-mesh-expansion" checked> 
          Enable MeSH term expansion
        </label><br>
        
        <label>
          <input type="checkbox" id="use-synonym-search" checked> 
          Enable synonym searching
        </label><br>
        
        <label>
          <input type="checkbox" id="use-concept-clustering" checked> 
          Enable concept clustering
        </label><br>
        
        <label>
          <input type="checkbox" id="use-self-reflection" checked> 
          Enable AI self-reflection on relevance
        </label><br>
        
        <h3>Export Options</h3>
        <button onclick="exportResults('json')" class="secondary-button">Export as JSON</button>
        <button onclick="exportResults('csv')" class="secondary-button">Export as CSV</button>
        <button onclick="exportResults('txt')" class="secondary-button">Export as Text</button>
      </div>
    </div>
  </div>

  <script>
    // ========== Enhanced Prompt Templates with Self-Reflection ==========
    // FIX: Added a strict instruction to all prompts to only return JSON.
    const JSON_INSTRUCTION = "IMPORTANT: Respond with ONLY the valid JSON object, without any additional text, commentary, or markdown formatting like ```json.";

    const PromptTemplates = {
      // Extract key concepts from the query
      EXTRACT_CONCEPTS: `Analyze this medical research query and extract the key concepts, entities, and relationships: "{query}"

Identify:
1. PRIMARY CONCEPTS: Core medical/biological terms that MUST appear in relevant articles
2. SECONDARY CONCEPTS: Related terms that enhance relevance
3. METHODOLOGICAL TERMS: Experimental approaches, techniques
4. ORGANISM/MODEL: Specific organisms, cell types, or models
5. RELATIONSHIPS: How concepts relate to each other

Also suggest:
- Synonyms for each concept
- Related MeSH terms
- Alternative spellings/nomenclature

Return as JSON:
{
  "primary_concepts": ["concept1", "concept2"],
  "secondary_concepts": ["concept3", "concept4"],
  "methodological_terms": ["method1", "method2"],
  "organism_model": ["organism1"],
  "synonyms": {
    "concept1": ["syn1", "syn2"],
    "concept2": ["syn3", "syn4"]
  },
  "mesh_terms": {
    "concept1": ["MeSH1", "MeSH2"],
    "concept2": ["MeSH3"]
  }
}
${JSON_INSTRUCTION}`,

      // Generate complex boolean searches
      GENERATE_COMPLEX_SEARCHES: `Based on these concepts and search history, generate 5 sophisticated PubMed search strategies:

Concepts: {concepts}
Previous searches: {previous_searches}
Previous lessons: {lessons}

Create searches that:
1. Use complex boolean logic: (A OR B) AND (C OR D)
2. Substitute synonyms strategically
3. Balance specificity and recall
4. Target different aspects of the research question
5. Learn from what worked/didn't work before

Use proper PubMed syntax with [MeSH], [tiab], quotations, etc.

Return as a JSON array of search strings.
${JSON_INSTRUCTION}`,

      // Self-reflection on search relevance
      SELF_REFLECTION: `Reflect on the relevance of these search strategies for the query: "{query}"

Search strategies:
{strategies}

For each strategy, consider:
1. Does it capture the core intent of the query?
2. Is it too broad or too narrow?
3. Are key concepts properly represented?
4. What might it miss?
5. Relevance score (0-100)

Return JSON:
[
  {
    "strategy_index": 1,
    "relevance_score": 85,
    "captures_intent": true,
    "potential_issues": "May be too specific on methodology",
    "missing_aspects": "Doesn't include related cell types",
    "recommendation": "Keep but add broader cell biology terms"
  }
]
${JSON_INSTRUCTION}`,

      // Enhanced article analysis with concept tracking
      ARTICLE_ANALYSIS_ENHANCED: `Analyze these articles for relevance to: "{query}"

Key concepts to track: {concepts}

For each article:
1. Relevance score (0-100)
2. Which key concepts are present/absent?
3. How well does it address the research question?
4. What unique insights does it provide?
5. Methodological relevance

Articles:
{articles}

Return JSON:
[
  {
    "index": 1,
    "score": 85,
    "concepts_present": ["Pard3", "knockout", "polarity"],
    "concepts_missing": ["cornea"],
    "reasoning": "Directly studies Pard3 knockout effects on cell polarity...",
    "unique_insights": "Novel mechanism for...",
    "methodological_match": true
  }
]
${JSON_INSTRUCTION}`,

      // Iteration insights with concept evolution
      ITERATION_INSIGHTS_ENHANCED: `Analyze iteration {iteration} for query: "{query}"

Key concepts tracked: {concepts}
Search terms used: {search_terms}
Top articles found: {articles_summary}

Provide:

CONCEPT EVOLUTION:
- Which concepts yielded good results?
- Which concepts need refinement?
- New related concepts discovered?

SEARCH EFFECTIVENESS:
- What search patterns worked well?
- What combinations were too broad/narrow?

LESSONS LEARNED:
- Key insights for next iteration
- Dead ends to avoid

NEXT STRATEGY:
- Specific concept combinations to try
- New angles to explore
- Refinements needed

Keep responses concise but actionable.`,

      // Final ranking with concept coverage
      FINAL_RANKING_ENHANCED: `Perform comprehensive ranking for query: "{query}"

Consider:
1. Concept coverage (which articles cover most key concepts)
2. Methodological relevance
3. Direct applicability to research question
4. Quality indicators (journal, recency, citations implied by methodology)
5. Unique contributions

Articles: {articles}

Rank ALL {count} articles from most to least relevant.
Return as a JSON array of article numbers: [3, 1, 7, 2, ...]
${JSON_INSTRUCTION}`,

      // Generate comprehensive summary
      SEARCH_SUMMARY_ENHANCED: `Create an executive summary of this iterative search:

Query: {query}
Key concepts identified: {concepts}
Search evolution: {evolution_data}

Provide:
1. CONCEPT LANDSCAPE: How key concepts relate in the literature
2. SEARCH EFFECTIVENESS: Which strategies worked best and why
3. KNOWLEDGE GAPS: What's missing in the literature
4. RECOMMENDATIONS: Next steps for research

Keep it concise but insightful (3-4 paragraphs).`,

      ABSTRACT_SUMMARY: `Analyze and synthesize these research articles:

{abstracts}

Create a comprehensive summary covering:
1. OVERVIEW: Main themes and consensus findings
2. KEY DISCOVERIES: Most important results across all papers
3. METHODOLOGICAL APPROACHES: Common techniques and innovations
4. CLINICAL/BIOLOGICAL SIGNIFICANCE: Real-world implications
5. CONTRADICTIONS: Any conflicting findings
6. FUTURE DIRECTIONS: Gaps and opportunities identified

Make it accessible yet thorough for researchers.`
    };

    // ========== Global State Management ==========
    let state = {
      config: {},
      searchState: {
        allArticles: {},
        iterationsData: [],
        finalRanking: [],
        totalInputTokens: 0,
        totalOutputTokens: 0,
        keyConcepts: null,
        conceptEvolution: {},
        searchHistory: []
      },
      abortController: null,
      currentTab: 'search'
    };

    // ========== Enhanced Token Counter ==========
    class TokenCounter {
      constructor() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
      
      // More accurate token estimation
      estimateTokens(text) {
        if (!text) return 0;
        const baseCount = text.length / 4;
        const specialChars = (text.match(/[{}\[\]"':,]/g) || []).length;
        return Math.ceil(baseCount + specialChars * 0.5);
      }
      
      addApiCall(prompt, response) {
        this.inputTokens += this.estimateTokens(prompt);
        this.outputTokens += this.estimateTokens(response);
        updateTokenDisplay();
      }
      
      getCostEstimate(model = "gpt-4-turbo") {
        const pricing = {
          "gpt-4-turbo": { input: 0.01, output: 0.03 },
          "gpt-4o": { input: 0.005, output: 0.015 },
          "gpt-4o-mini": { input: 0.00015, output: 0.0006 },
          "gpt-4": { input: 0.03, output: 0.06 },
          "gpt-3.5-turbo": { input: 0.0005, output: 0.0015 }
        };
        
        const modelPricing = pricing[model] || pricing["gpt-4-turbo"];
        const inputCost = (this.inputTokens / 1000) * modelPricing.input;
        const outputCost = (this.outputTokens / 1000) * modelPricing.output;
        
        return inputCost + outputCost;
      }
      
      reset() {
        this.inputTokens = 0;
        this.outputTokens = 0;
      }
    }

    const tokenCounter = new TokenCounter();

    // ========== Core Configuration ==========
    const CORS_PROXIES = [
      'https://corsproxy.io/?',
      'https://api.allorigins.win/raw?url=',
      'https://proxy.cors.sh/',
    ];
    let currentProxyIndex = 0;
    const NCBI_REQUEST_DELAY_MS = 400;
    const isRunningLocally = window.location.protocol === 'file:';

    // ========== Enhanced Helper Functions ==========
    
    function showTab(event, tabName) {
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.getElementById(`${tabName}-tab`).classList.add('active');
      event.currentTarget.classList.add('active');
      state.currentTab = tabName;
    }

    // FIX: Made logging safer to avoid `NaN` and blank lines.
    function logMessage(message, category = 'info', isHtml = false) {
      if (message === undefined || message === null) return;
      
      const logArea = document.getElementById("iteration-log");
      const timestamp = new Date().toLocaleTimeString();
      
      let formattedMessage = String(message); // Ensure message is a string
      if (!formattedMessage.trim() && !isHtml) return;

      if (category === 'error') {
        formattedMessage = `‚ùå ${formattedMessage}`;
      } else if (category === 'success') {
        formattedMessage = `‚úÖ ${formattedMessage}`;
      } else if (category === 'warning') {
        formattedMessage = `‚ö†Ô∏è ${formattedMessage}`;
      } else if (category === 'concept') {
        formattedMessage = `üß¨ ${formattedMessage}`;
      }
      
      if (isHtml) {
        logArea.innerHTML += `<div class="log-entry log-${category}">[${timestamp}] ${formattedMessage}</div>`;
      } else {
        const textNode = document.createTextNode(`[${timestamp}] ${formattedMessage}\n`);
        logArea.appendChild(textNode);
      }
      logArea.scrollTop = logArea.scrollHeight;
    }

    function updateTokenDisplay() {
      const cost = tokenCounter.getCostEstimate(state.config.modelChoice);
      const display = document.getElementById("token-display");
      display.textContent = `üî§ Tokens - In: ${tokenCounter.inputTokens.toLocaleString()} | Out: ${tokenCounter.outputTokens.toLocaleString()} | Est. Cost: $${cost.toFixed(4)}`;
    }

    function displayKeyConcepts(concepts) {
      const conceptDisplay = document.getElementById("concept-display");
      const conceptTags = document.getElementById("concept-tags");
      
      conceptDisplay.style.display = 'block';
      conceptTags.innerHTML = '';
      
      concepts.primary_concepts.forEach(concept => {
        const tag = document.createElement('span');
        tag.className = 'concept-tag primary';
        tag.textContent = concept;
        conceptTags.appendChild(tag);
      });
      
      concepts.secondary_concepts.forEach(concept => {
        const tag = document.createElement('span');
        tag.className = 'concept-tag';
        tag.textContent = concept;
        conceptTags.appendChild(tag);
      });
    }

    // FIX: This function is now more robust against non-JSON text from the API.
    // FIX: It also correctly re-throws AbortError to stop the execution chain.
    async function callOpenAI(prompt, temperature = 0.3, maxTokens = 1500) {
      const requestBody = {
        model: state.config.modelChoice,
        messages: [{ role: "user", content: prompt }],
        temperature: temperature,
        max_tokens: maxTokens
      };
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${state.config.openAIKey}`
          },
          body: JSON.stringify(requestBody),
          signal: state.abortController?.signal
        });
        
        const responseText = await response.text();
        
        if (!response.ok) {
          let errorMessage = `OpenAI API Error: ${response.status} ${response.statusText}`;
          try {
            const errorData = JSON.parse(responseText);
            if (errorData.error?.message) errorMessage = `OpenAI API Error: ${errorData.error.message}`;
          } catch (e) {
            errorMessage += `\nResponse: ${responseText.substring(0, 200)}`;
          }
          throw new Error(errorMessage);
        }
        
        const data = JSON.parse(responseText);
        
        if (!data.choices || data.choices.length === 0) {
          throw new Error("No response from OpenAI API");
        }
        
        let text = data.choices[0].message.content.trim();
        
        // Robust JSON extraction
        const jsonMatch = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
        if (jsonMatch) {
            text = jsonMatch[0];
        }

        tokenCounter.addApiCall(prompt, text);
        return text;

      } catch (error) {
        if (error.name === 'AbortError') {
          logMessage("API call cancelled by user.", 'warning');
        } else {
          logMessage(`API call failed: ${error.message}`, 'error');
        }
        // IMPORTANT: Re-throw the error so the calling function knows to stop.
        throw error;
      }
    }

    async function extractKeyConcepts(query) {
      logMessage("üß¨ EXTRACTING KEY CONCEPTS", 'concept');
      
      const prompt = PromptTemplates.EXTRACT_CONCEPTS.replace("{query}", query);
      
      try {
        const response = await callOpenAI(prompt, 0.3, 800);
        const concepts = JSON.parse(response);
        
        logMessage("Identified key concepts:", 'concept');
        logMessage(`  Primary: ${concepts.primary_concepts.join(", ")}`, 'concept');
        logMessage(`  Secondary: ${concepts.secondary_concepts.join(", ")}`, 'concept');
        logMessage(`  Methods: ${concepts.methodological_terms.join(", ")}`, 'concept');
        
        state.searchState.keyConcepts = concepts;
        displayKeyConcepts(concepts);
        
        return concepts;
      } catch (e) {
        logMessage(`Failed to extract concepts: ${e.message}`, 'error');
        // Re-throw to stop the search if concept extraction fails
        throw e;
      }
    }

    // FIX: Ensure AbortError is re-thrown to halt the search
    async function generateComplexSearches(iteration, query, concepts) {
      logMessage("üîç GENERATING COMPLEX SEARCH STRATEGIES", 'info');
      
      const context = {
        concepts: JSON.stringify(concepts),
        previous_searches: JSON.stringify(state.searchState.searchHistory.slice(-10)),
        lessons: state.searchState.iterationsData.slice(-2).map(d => d.lessons).join("; ")
      };
      
      const prompt = PromptTemplates.GENERATE_COMPLEX_SEARCHES
        .replace("{concepts}", context.concepts)
        .replace("{previous_searches}", context.previous_searches)
        .replace("{lessons}", context.lessons);
      
      try {
        const response = await callOpenAI(prompt, 0.4, 800);
        let searches = JSON.parse(response);
        
        if (document.getElementById('use-self-reflection').checked) {
          searches = await reflectOnSearchRelevance(query, searches);
        }
        
        return searches;
      } catch (e) {
        logMessage(`Failed to generate complex searches: ${e.message}`, 'error');
        throw e;
      }
    }
    
    // FIX: Ensure AbortError is re-thrown to halt the search
    async function reflectOnSearchRelevance(query, strategies) {
      logMessage("ü§î Reflecting on search relevance...", 'info');
      
      const prompt = PromptTemplates.SELF_REFLECTION
        .replace("{query}", query)
        .replace("{strategies}", JSON.stringify(strategies));
      
      try {
        const response = await callOpenAI(prompt, 0.2, 600);
        const reflections = JSON.parse(response);
        
        const refinedStrategies = [];
        reflections.forEach((reflection, index) => {
          if (reflection.relevance_score >= 60) {
            refinedStrategies.push(strategies[index]);
            if (reflection.recommendation.includes("add")) {
              logMessage(`  Strategy ${index + 1}: Good (${reflection.relevance_score}/100) - ${reflection.recommendation}`, 'success');
            }
          } else {
            logMessage(`  Strategy ${index + 1}: Poor (${reflection.relevance_score}/100) - Skipping`, 'warning');
          }
        });
        
        return refinedStrategies.length > 0 ? refinedStrategies : strategies.slice(0, 3);
      } catch (e) {
        if (e.name !== 'AbortError') {
            logMessage(`Self-reflection failed: ${e.message}`, 'warning');
        }
        // If it fails (including cancellation), throw to stop or just return original strategies
        throw e;
      }
    }

    // ... The rest of the JS code remains largely the same, but the fixes above are the crucial ones ...

    async function cancellableFetch(url, options = {}) {
      let lastError;
      
      if (isRunningLocally && !window.corsWarningShown) {
        logMessage("Running from local file detected. CORS proxies may be limited.", 'warning');
        logMessage("For best results, use a local web server or host online.", 'warning');
        window.corsWarningShown = true;
      }
      
      for (let i = 0; i < CORS_PROXIES.length; i++) {
        const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
        const proxy = CORS_PROXIES[proxyIndex];
        const proxiedUrl = proxy + encodeURIComponent(url);
        
        try {
          const response = await fetch(proxiedUrl, { ...options, signal: state.abortController?.signal });
          if (response.ok) {
            currentProxyIndex = proxyIndex;
            return response;
          }
          lastError = new Error(`Proxy ${proxy} returned status ${response.status}`);
        } catch (error) {
          lastError = error;
          if (error.name === 'AbortError') throw error;
        }
      }
      
      logMessage(`All CORS proxies failed. ${isRunningLocally ? 'Please host this file online.' : 'Try again later.'}`, 'error');
      throw lastError || new Error('All CORS proxies failed');
    }

    async function searchPubMed(query, maxResults = 20) {
      const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(query)}&retmode=xml&retmax=${maxResults}&tool=Enhanced_AI_PubMed_Searcher&email=research.tool@example.com&sort=relevance`;
      
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) throw new Error(`PubMed search error: ${resp.status}`);
        const xmlText = await resp.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "text/xml");
        const errorNode = xmlDoc.querySelector("ERROR");
        if (errorNode) throw new Error(`PubMed API error: ${errorNode.textContent}`);
        const idElements = Array.from(xmlDoc.getElementsByTagName("Id"));
        return idElements.map(idNode => idNode.textContent);
      } catch (error) {
        if (error.name !== 'AbortError') {
          logMessage(`PubMed search error: ${error.message}`, 'error');
        }
        throw error;
      }
    }

    async function fetchPubMedDetails(pmids) {
      if (pmids.length === 0) return [];
      const BATCH_SIZE = 100;
      let articles = [];
      for (let i = 0; i < pmids.length; i += BATCH_SIZE) {
        const batchIds = pmids.slice(i, i + BATCH_SIZE).join(",");
        const url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${batchIds}&retmode=xml&tool=Enhanced_AI_PubMed_Searcher&email=research.tool@example.com`;
        try {
          const resp = await cancellableFetch(url);
          if (!resp.ok) throw new Error(`PubMed fetch error: ${resp.status}`);
          const xmlText = await resp.text();
          const xmlDoc = new DOMParser().parseFromString(xmlText, "text/xml");
          const articleNodes = Array.from(xmlDoc.getElementsByTagName("PubmedArticle"));
          articles.push(...articleNodes.map(parseArticleXML));
        } catch (error) {
          if (error.name !== 'AbortError') {
            logMessage(`PubMed fetch error: ${error.message}`, 'error');
          }
          throw error;
        }
      }
      return articles;
    }

    function parseArticleXML(articleNode) {
      function textOrDefault(elem, tag, defaultVal = "") {
        const node = elem.getElementsByTagName(tag)[0];
        return node && node.textContent ? node.textContent : defaultVal;
      }
      const pmid = textOrDefault(articleNode, "PMID", "Unknown");
      const title = textOrDefault(articleNode, "ArticleTitle", "No Title Available");
      const authors = Array.from(articleNode.getElementsByTagName("Author")).map(auth => {
        const lastName = textOrDefault(auth, "LastName");
        const foreName = textOrDefault(auth, "ForeName");
        return lastName ? (foreName ? `${lastName}, ${foreName}` : lastName) : null;
      }).filter(Boolean);
      const journal = textOrDefault(articleNode, "Title", "Unknown Journal");
      const pubDateNode = articleNode.getElementsByTagName("PubDate")[0];
      let pubYear = "Unknown";
      if (pubDateNode) {
        const year = textOrDefault(pubDateNode, "Year");
        const medlineDate = textOrDefault(pubDateNode, "MedlineDate");
        pubYear = year || (medlineDate ? medlineDate.substring(0, 4) : "Unknown");
      }
      const abstractTexts = [];
      const abstractNodes = articleNode.getElementsByTagName("AbstractText");
      for (const node of abstractNodes) {
        const label = node.getAttribute("Label");
        const text = node.textContent;
        if (text) abstractTexts.push(label ? `${label}: ${text}` : text);
      }
      const abstract = abstractTexts.join(" ").trim();
      return { pmid, title, authors, journal, pub_date: pubYear, abstract, relevance_score: 0, ai_reasoning: "", found_in_iteration: 0, concepts_present: [], concepts_missing: [], unique_insights: "" };
    }

    async function analyzeArticlesEnhanced(query, articlesList, concepts) {
      if (articlesList.length === 0) return [];
      logMessage("ü§ñ Analyzing articles with enhanced concept tracking...", 'info');
      const articleInfo = articlesList.map((a, i) => ({ index: i + 1, pmid: a.pmid, title: a.title, abstract: (a.abstract || "").substring(0, 1000) + (a.abstract?.length > 1000 ? "..." : ""), journal: a.journal, year: a.pub_date }));
      const prompt = PromptTemplates.ARTICLE_ANALYSIS_ENHANCED.replace("{query}", query).replace("{concepts}", JSON.stringify(concepts)).replace("{articles}", JSON.stringify(articleInfo, null, 2));
      try {
        const responseText = await callOpenAI(prompt, 0.2, 2000);
        const results = JSON.parse(responseText);
        results.forEach(res => {
          if (articlesList[res.index - 1]) {
            const article = articlesList[res.index - 1];
            article.relevance_score = res.score || 0;
            article.ai_reasoning = res.reasoning || "No reasoning provided.";
            article.concepts_present = res.concepts_present || [];
            article.concepts_missing = res.concepts_missing || [];
            article.unique_insights = res.unique_insights || "";
            article.methodological_match = res.methodological_match || false;
          }
        });
        updateConceptEvolution(results);
      } catch (e) {
        if (e.name === 'AbortError') throw e;
        logMessage(`AI analysis failed: ${e.message}. Using fallback scoring.`, 'error');
        articlesList.forEach(a => { a.relevance_score = 50; a.ai_reasoning = "AI analysis failed - fallback scoring applied."; });
      }
      return articlesList;
    }

    function updateConceptEvolution(analysisResults) {
      if (!state.searchState.conceptEvolution) state.searchState.conceptEvolution = {};
      analysisResults.forEach(result => {
        (result.concepts_present || []).forEach(concept => {
          if (!state.searchState.conceptEvolution[concept]) {
            state.searchState.conceptEvolution[concept] = { frequency: 0, avgScore: 0, articles: [] };
          }
          const evolution = state.searchState.conceptEvolution[concept];
          evolution.frequency++;
          evolution.avgScore = ((evolution.avgScore * (evolution.frequency - 1)) + result.score) / evolution.frequency;
          evolution.articles.push(result.index);
        });
      });
    }

    async function getIterationInsightsEnhanced(query, iter, searchTerms, topArticles, concepts) {
      const summary = topArticles.slice(0, 5).map((a, i) => `${i + 1}. ${a.title} (Score: ${a.relevance_score.toFixed(0)}, Concepts: ${a.concepts_present.join(", ")})`).join("\n");
      const prompt = PromptTemplates.ITERATION_INSIGHTS_ENHANCED.replace("{query}", query).replace("{iteration}", iter).replace("{concepts}", JSON.stringify(concepts)).replace("{search_terms}", JSON.stringify(searchTerms)).replace("{articles_summary}", summary);
      try {
        const responseText = await callOpenAI(prompt, 0.3, 800);
        const conceptEvolution = responseText.match(/CONCEPT EVOLUTION:([\s\S]*?)SEARCH EFFECTIVENESS:/)?.[1]?.trim() || "";
        const searchEffectiveness = responseText.match(/SEARCH EFFECTIVENESS:([\s\S]*?)LESSONS LEARNED:/)?.[1]?.trim() || "";
        const lessons = responseText.match(/LESSONS LEARNED:([\s\S]*?)NEXT STRATEGY:/)?.[1]?.trim() || "";
        const nextStrategy = responseText.match(/NEXT STRATEGY:([\s\S]*)/)?.[1]?.trim() || "";
        return { conceptEvolution, searchEffectiveness, lessons, nextStrategy };
      } catch (e) {
        if (e.name === 'AbortError') throw e;
        logMessage(`Insights generation failed: ${e.message}`, 'error');
        return { lessons: "Continue with current approach", nextStrategy: "Maintain search strategy" };
      }
    }

    async function verifyMeshTerm(term) {
      const url = `https://id.nlm.nih.gov/mesh/lookup/descriptor?label=${encodeURIComponent(term)}&match=exact&limit=1`;
      try {
        const resp = await cancellableFetch(url);
        if (!resp.ok) return false;
        const data = await resp.json();
        return Array.isArray(data) && data.length > 0;
      } catch (error) {
        if (error.name === 'AbortError') throw error;
        console.warn("MeSH verification error:", error);
        return false;
      }
    }

    async function runEnhancedIterativeSearch(query) {
      toggleUI(true);
      resetSearchState();
      state.abortController = new AbortController();
      clearAllDisplays();
      logMessage(`üöÄ Starting enhanced iterative search for: "${query}"`, 'success');
      
      try {
        const concepts = await extractKeyConcepts(query);
        for (let iter = 1; iter <= state.config.totalIterations; iter++) {
          if (state.abortController.signal.aborted) throw new Error("Search cancelled");
          logMessage(`\nüîÑ ITERATION ${iter}/${state.config.totalIterations}`, 'info');
          const searchTerms = await generateComplexSearches(iter, query, concepts);
          if (document.getElementById('use-mesh-expansion').checked) await verifyAndHighlightMeshTerms(searchTerms);
          logMessage("üì° Searching PubMed...", 'info');
          const pmidResults = await executeSearchStrategies(searchTerms);
          const { currentArticles } = await processSearchResults(pmidResults, iter);
          if (currentArticles.length === 0) {
            logMessage("No articles found this iteration. Adjusting strategy...", 'warning');
            continue;
          }
          const analyzedArticles = await analyzeArticlesEnhanced(query, currentArticles, concepts);
          analyzedArticles.sort((a, b) => b.relevance_score - a.relevance_score);
          const topArticles = analyzedArticles.slice(0, state.config.topArticlesPerIteration);
          const insights = await getIterationInsightsEnhanced(query, iter, searchTerms, topArticles, concepts);
          displayIterationSummary(iter, topArticles, insights);
          state.searchState.iterationsData.push({ number: iter, searchTerms, topArticles, ...insights, uniqueArticles: currentArticles.length });
          state.searchState.searchHistory.push(...searchTerms);
        }
        await finalizeAndDisplayResults(query, concepts);
      } catch (error) {
        handleSearchError(error);
      } finally {
        toggleUI(false);
      }
    }

    async function verifyAndHighlightMeshTerms(searchTerms) {
      logMessage("üî¨ Verifying MeSH terms...", 'info');
      const meshPattern = /\[([^\]]+?)\]/g;
      const uniqueMeshTerms = [...new Set(searchTerms.flatMap(term => (term.match(meshPattern) || []).map(m => m.slice(1, -1))))];
      const invalidTerms = new Set();
      for (const term of uniqueMeshTerms) {
        if (!await verifyMeshTerm(term)) invalidTerms.add(term);
        await new Promise(resolve => setTimeout(resolve, NCBI_REQUEST_DELAY_MS));
      }
      logMessage("Search strategies:", 'info');
      searchTerms.forEach((s, i) => {
        let highlighted = s.replace(meshPattern, (match, term) => invalidTerms.has(term) ? `<span class="invalid-mesh">${match}</span>` : match);
        logMessage(`${i + 1}. ${highlighted}`, 'info', true);
      });
    }

    async function executeSearchStrategies(searchTerms) {
      const perTermCount = Math.ceil(state.config.articlesPerIteration / searchTerms.length) + 5;
      const pmidArrays = [];
      for (const [index, term] of searchTerms.entries()) {
        logMessage(`  Executing search ${index + 1}/${searchTerms.length}...`, 'info');
        const pmids = await searchPubMed(term, perTermCount);
        pmidArrays.push(pmids);
        logMessage(` Found ${pmids.length} articles`, 'success');
        await new Promise(resolve => setTimeout(resolve, NCBI_REQUEST_DELAY_MS));
      }
      return pmidArrays;
    }

    async function processSearchResults(pmidArrays, iteration) {
      const uniquePmids = [...new Set(pmidArrays.flat())];
      logMessage(`üìä Found ${uniquePmids.length} unique articles in iteration ${iteration}`, 'info');
      const newPmids = uniquePmids.filter(pmid => !state.searchState.allArticles[pmid]);
      if (newPmids.length > 0) {
        logMessage(`  Fetching details for ${newPmids.length} new articles...`, 'info');
        const fetchedArticles = await fetchPubMedDetails(newPmids);
        fetchedArticles.forEach(article => {
          article.found_in_iteration = iteration;
          state.searchState.allArticles[article.pmid] = article;
        });
      }
      const currentArticles = uniquePmids.map(pmid => state.searchState.allArticles[pmid]).filter(Boolean);
      return { currentArticles };
    }

    function displayIterationSummary(iteration, topArticles, insights) {
      logMessage(`\nüìà ITERATION ${iteration} SUMMARY:`, 'success');
      if (topArticles.length > 0) {
        logMessage("üèÜ Top articles:", 'info');
        topArticles.slice(0, 3).forEach((article, i) => {
          const scoreClass = article.relevance_score >= 80 ? 'good-score' : article.relevance_score >= 60 ? 'medium-score' : 'poor-score';
          logMessage(`${i + 1}. ${article.title.substring(0, 100)}...`, 'info');
          logMessage(`   Score: <span class="${scoreClass}">${article.relevance_score.toFixed(1)}</span> | Concepts: ${article.concepts_present.join(", ")}`, 'info', true);
        });
      }
      logMessage(`üí° Insights: ${insights.lessons}`, 'info');
      logMessage(`üéØ Next strategy: ${insights.nextStrategy}`, 'info');
    }

    async function finalizeAndDisplayResults(query, concepts) {
      const allArticles = Object.values(state.searchState.allArticles);
      if (allArticles.length === 0) {
        logMessage("‚ö†Ô∏è No articles found in the search.", 'warning');
        return;
      }
      logMessage(`\nüéØ FINALIZING RESULTS`, 'success');
      logMessage(`Total unique articles found: ${allArticles.length}`, 'info');
      const articleSummary = allArticles.map((a, i) => ({ number: i + 1, pmid: a.pmid, title: a.title, relevance_score: a.relevance_score, concepts_present: a.concepts_present || [], found_in_iteration: a.found_in_iteration }));
      const prompt = PromptTemplates.FINAL_RANKING_ENHANCED.replace("{query}", query).replace("{articles}", JSON.stringify(articleSummary, null, 2)).replace("{count}", allArticles.length);
      try {
        const responseText = await callOpenAI(prompt, 0.2, 1000);
        const rankingIndices = JSON.parse(responseText);
        state.searchState.finalRanking = rankingIndices.map(idx => allArticles[idx - 1]).filter(Boolean);
      } catch (e) {
        if (e.name === 'AbortError') throw e;
        logMessage(`AI ranking failed, using score-based ranking: ${e.message}`, 'warning');
        state.searchState.finalRanking = [...allArticles].sort((a, b) => b.relevance_score - a.relevance_score);
      }
      displayTopArticles();
      displayEvolutionAnalysis(concepts);
      displayFinalRankings();
      await generateSearchSummary(query, concepts);
      logMessage("‚úÖ Search completed successfully!", 'success');
      document.getElementById("progress-status").textContent = "‚úÖ Enhanced search completed!";
    }

    function displayTopArticles() {
      const resultsDiv = document.getElementById("results");
      const topArticles = state.searchState.finalRanking.slice(0, 15);
      let html = '<h3>Top Articles with Abstracts</h3>';
      topArticles.forEach((article, i) => {
        const scoreClass = article.relevance_score >= 80 ? 'good-score' : article.relevance_score >= 60 ? 'medium-score' : 'poor-score';
        html += `<div class="article-result"><h4>#${i + 1}: ${escapeHtml(article.title)}</h4><div class="article-metadata"><strong>Authors:</strong> ${article.authors.slice(0, 3).join(", ")}${article.authors.length > 3 ? ` + ${article.authors.length - 3} more` : ''}<br><strong>Journal:</strong> ${escapeHtml(article.journal)} (${article.pub_date})<br><strong>PMID:</strong> ${article.pmid} | <strong>Score:</strong> <span class="${scoreClass}">${article.relevance_score.toFixed(1)}/100</span><br><strong>URL:</strong> <a href="https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/" target="_blank">View on PubMed</a><br><strong>Found in iteration:</strong> ${article.found_in_iteration}`;
        if (article.concepts_present?.length > 0) html += `<br><strong>Key concepts present:</strong> ${article.concepts_present.map(c => `<span class="concept-tag">${c}</span>`).join(' ')}`;
        html += `<br><strong>AI Assessment:</strong> ${escapeHtml(article.ai_reasoning)}`;
        if (article.unique_insights) html += `<br><strong>Unique insights:</strong> ${escapeHtml(article.unique_insights)}`;
        html += `</div><div class="article-abstract"><strong>Abstract:</strong><br>${escapeHtml(article.abstract || "Not available")}</div></div>`;
      });
      resultsDiv.innerHTML = html;
    }

    function displayEvolutionAnalysis(concepts) {
      const evolutionDiv = document.getElementById("evolution");
      const conceptEvolutionDiv = document.getElementById("concept-evolution");
      let evolutionText = `SEARCH EVOLUTION OVERVIEW\n${"=" * 50}\n\nTotal iterations: ${state.searchState.iterationsData.length}\nTotal unique articles: ${Object.keys(state.searchState.allArticles).length}\n\n`;
      state.searchState.iterationsData.forEach(iter => {
        evolutionText += `Iteration ${iter.number}:\n  ‚Ä¢ Strategies used: ${iter.searchTerms.length}\n  ‚Ä¢ Articles found: ${iter.uniqueArticles}\n  ‚Ä¢ Best score: ${iter.topArticles[0]?.relevance_score.toFixed(1) || 'N/A'}\n  ‚Ä¢ Key lesson: ${iter.lessons.substring(0, 100)}...\n\n`;
      });
      evolutionDiv.textContent = evolutionText;

      let conceptText = `CONCEPT EVOLUTION ANALYSIS\n${"=" * 50}\n\n`;
      const sortedConcepts = Object.entries(state.searchState.conceptEvolution).sort((a, b) => b[1].avgScore - a[1].avgScore);
      conceptText += "Most effective concepts (by average relevance score):\n\n";
      sortedConcepts.forEach(([concept, data]) => {
        conceptText += `‚Ä¢ ${concept}:\n  - Frequency: ${data.frequency} articles\n  - Avg Score: ${data.avgScore.toFixed(1)}/100\n\n`;
      });
      const allConcepts = [...concepts.primary_concepts, ...concepts.secondary_concepts, ...concepts.methodological_terms];
      const missingConcepts = allConcepts.filter(c => !state.searchState.conceptEvolution[c] || state.searchState.conceptEvolution[c].frequency < 2);
      if (missingConcepts.length > 0) conceptText += `\n‚ö†Ô∏è Underrepresented concepts:\n${missingConcepts.map(c => `  - ${c}`).join('\n')}`;
      conceptEvolutionDiv.textContent = conceptText;
    }

    function displayFinalRankings() {
      const rankingsDiv = document.getElementById("rankings");
      let rankingsText = `COMPLETE ARTICLE RANKINGS\n${"=" * 50}\n\nTotal articles ranked: ${state.searchState.finalRanking.length}\n\n`;
      state.searchState.finalRanking.forEach((article, i) => {
        const scoreClass = article.relevance_score >= 80 ? 'üü¢' : article.relevance_score >= 60 ? 'üü°' : 'üî¥';
        rankingsText += `${i + 1}. ${scoreClass} ${article.title}\n   Journal: ${article.journal} (${article.pub_date})\n   PMID: ${article.pmid} | Score: ${article.relevance_score.toFixed(1)}\n   URL: https://pubmed.ncbi.nlm.nih.gov/${article.pmid}/\n\n`;
      });
      rankingsDiv.textContent = rankingsText;
    }

    async function generateSearchSummary(query, concepts) {
      logMessage("üìù Generating comprehensive search summary...", 'info');
      const evolutionData = { query, total_iterations: state.searchState.iterationsData.length, total_articles: Object.keys(state.searchState.allArticles).length, iteration_summaries: state.searchState.iterationsData.map(iter => ({ number: iter.number, articles: iter.uniqueArticles, best_score: iter.topArticles[0]?.relevance_score || 0 })) };
      const prompt = PromptTemplates.SEARCH_SUMMARY_ENHANCED.replace("{query}", query).replace("{concepts}", JSON.stringify(concepts)).replace("{evolution_data}", JSON.stringify(evolutionData, null, 2));
      try {
        const summary = await callOpenAI(prompt, 0.3, 800);
        document.getElementById("evolution").textContent += `\n\nEXECUTIVE SUMMARY\n${"=" * 50}\n\n${summary}`;
      } catch (e) {
        if (e.name === 'AbortError') throw e;
        logMessage(`Summary generation failed: ${e.message}`, 'error');
      }
    }

    async function generateAbstractSummary() {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) {
        alert("No results available to summarize."); return;
      }
      const count = parseInt(document.getElementById("summary-count").value, 10) || 5;
      const topN = state.searchState.finalRanking.slice(0, count);
      const summaryDiv = document.getElementById("summary");
      summaryDiv.textContent = "Generating AI summary... Please wait.";
      let abstractsText = "";
      topN.forEach((article, i) => {
        abstractsText += `\n${i + 1}. ${article.title}\n   Abstract: ${article.abstract || "Not available"}\n`;
      });
      const summaryPrompt = PromptTemplates.ABSTRACT_SUMMARY.replace("{abstracts}", abstractsText);
      try {
        const summaryResponse = await callOpenAI(summaryPrompt, 0.3, 1200);
        summaryDiv.textContent = `AI SUMMARY OF TOP ${count} ARTICLES\n${"=".repeat(50)}\n\n${summaryResponse}`;
      } catch (e) {
        summaryDiv.textContent = `‚ùå Error generating summary: ${e.message}`;
      }
    }

    function handleSearchError(error) {
      if (error.name === 'AbortError' || error.message === 'Search cancelled') {
        document.getElementById("progress-status").textContent = "‚ùå Search cancelled.";
        logMessage("Search cancelled by user.", 'warning');
      } else {
        document.getElementById("progress-status").textContent = "‚ùå An error occurred.";
        logMessage(`Search error: ${error.message}`, 'error');
      }
    }
    
    function clearAllDisplays() {
        ['iteration-log', 'results', 'summary', 'evolution', 'concept-evolution', 'rankings'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.innerHTML = '';
        });
        const conceptDisplay = document.getElementById('concept-display');
        if (conceptDisplay) conceptDisplay.style.display = 'none';
    }

    function resetSearchState() {
      state.searchState = { allArticles: {}, iterationsData: [], finalRanking: [], keyConcepts: null, conceptEvolution: {}, searchHistory: [] };
      tokenCounter.reset();
      updateTokenDisplay();
    }

    function toggleUI(isSearching) {
      document.getElementById("start-btn").disabled = isSearching;
      document.getElementById("start-btn").style.display = isSearching ? 'none' : 'inline-block';
      document.getElementById("cancel-btn").style.display = isSearching ? 'inline-block' : 'none';
      if (isSearching) document.getElementById("progress-status").innerHTML = 'Searching... <span class="spinner"></span>';
      document.querySelectorAll('#config-section input, #config-section select, #query-section input, #query-section select').forEach(el => el.disabled = isSearching);
    }
    
    // ... all other functions (export, testAPI, etc.) are the same
    function exportResults(format) {
      if (!state.searchState.finalRanking || state.searchState.finalRanking.length === 0) { alert("No results to export."); return; }
      let content = '', filename = `pubmed_results_${new Date().toISOString().split('T')[0]}`, mimeType = 'text/plain';
      if (format === 'json') {
        content = JSON.stringify({ query: document.getElementById("query-input").value, date: new Date().toISOString(), articles: state.searchState.finalRanking }, null, 2);
        filename += '.json'; mimeType = 'application/json';
      } else if (format === 'csv') {
        content = 'Rank,PMID,Title,Authors,Journal,Year,Score,URL\n';
        state.searchState.finalRanking.forEach((a, i) => { content += `${i + 1},"${a.pmid}","${a.title.replace(/"/g, '""')}","${a.authors.slice(0, 3).join('; ')}","${a.journal.replace(/"/g, '""')}",${a.pub_date},${a.relevance_score.toFixed(1)},https://pubmed.ncbi.nlm.nih.gov/${a.pmid}/\n`; });
        filename += '.csv'; mimeType = 'text/csv';
      } else {
        content = `SEARCH RESULTS\n${"=".repeat(60)}\n\nQuery: ${document.getElementById("query-input").value}\n\n`;
        state.searchState.finalRanking.forEach((a, i) => { content += `#${i+1} | ${a.title}\nPMID: ${a.pmid} | Score: ${a.relevance_score.toFixed(1)}\nURL: https://pubmed.ncbi.nlm.nih.gov/${a.pmid}/\n\n${a.abstract}\n\n`; });
        filename += '.txt';
      }
      const blob = new Blob([content], { type: mimeType });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download = filename;
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
    }
    function validateAPIKey(key) {
      if (!key || key.trim().length < 10) return { valid: false, message: "API key is too short or empty" };
      if (!key.startsWith('sk-')) return { valid: false, message: "API key format appears invalid (should start with 'sk-')" };
      return { valid: true };
    }
    async function testAPIKey() {
      const apiKey = document.getElementById("api-key").value.trim();
      const resultDiv = document.getElementById("api-test-result");
      if (!validateAPIKey(apiKey).valid) {
        resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå Invalid API key format.</div>`; return;
      }
      resultDiv.innerHTML = '<div class="api-test-result">Testing...</div>';
      try {
        const response = await fetch("https://api.openai.com/v1/models", { headers: { "Authorization": `Bearer ${apiKey}` } });
        if (response.ok) {
          resultDiv.innerHTML = '<div class="api-test-result api-test-success">‚úÖ API key is valid!</div>';
        } else {
          resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå API key invalid: ${response.statusText}</div>`;
        }
      } catch (error) {
        resultDiv.innerHTML = `<div class="api-test-result api-test-failure">‚ùå Connection error.</div>`;
      }
    }
    function escapeHtml(text) {
        if (!text) return "";
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // ========== Event Listeners ==========
    document.getElementById("test-api-btn").addEventListener("click", testAPIKey);
    document.getElementById("start-btn").addEventListener("click", () => {
      state.config = {
        openAIKey: document.getElementById("api-key").value.trim(),
        modelChoice: document.getElementById("model-select").value,
        totalIterations: parseInt(document.getElementById("iterations").value, 10),
        articlesPerIteration: parseInt(document.getElementById("articles-per-iter").value, 10),
        topArticlesPerIteration: parseInt(document.getElementById("top-articles").value, 10),
      };
      const query = document.getElementById("query-input").value.trim();
      const validation = validateAPIKey(state.config.openAIKey);
      if (!validation.valid) { alert(`Invalid API key: ${validation.message}`); return; }
      if (!query) { alert("Please enter a research query."); return; }
      runEnhancedIterativeSearch(query);
    });
    document.getElementById("cancel-btn").addEventListener("click", () => {
      if (state.abortController) state.abortController.abort();
    });
    document.getElementById("summary-btn").addEventListener("click", generateAbstractSummary);
    window.addEventListener('load', () => {
      document.getElementById("query-input").focus();
      if (isRunningLocally) document.getElementById('cors-warning').style.display = 'block';
      document.getElementById("query-input").addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !document.getElementById("start-btn").disabled) document.getElementById("start-btn").click();
      });
    });
  </script>
</body>
</html>
